// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

package rancher2

import (
	"reflect"

	"github.com/pkg/errors"
	"github.com/pulumi/pulumi/sdk/v2/go/pulumi"
)

type MultiClusterApp struct {
	pulumi.CustomResourceState

	// Annotations of the resource
	Annotations pulumi.MapOutput `pulumi:"annotations"`
	// Multi cluster app answers
	Answers MultiClusterAppAnswerArrayOutput `pulumi:"answers"`
	// Multi cluster app catalog name
	CatalogName pulumi.StringOutput `pulumi:"catalogName"`
	// Labels of the resource
	Labels pulumi.MapOutput `pulumi:"labels"`
	// Multi cluster app members
	Members MultiClusterAppMemberArrayOutput `pulumi:"members"`
	// Multi cluster app name
	Name pulumi.StringOutput `pulumi:"name"`
	// Multi cluster app revision history limit
	RevisionHistoryLimit pulumi.IntPtrOutput `pulumi:"revisionHistoryLimit"`
	// Multi cluster app revision name
	RevisionId pulumi.StringOutput `pulumi:"revisionId"`
	// Multi cluster app roles
	Roles pulumi.StringArrayOutput `pulumi:"roles"`
	// Multi cluster app targets
	Targets MultiClusterAppTargetArrayOutput `pulumi:"targets"`
	// Multi cluster app template name
	TemplateName pulumi.StringOutput `pulumi:"templateName"`
	// Multi cluster app template version
	TemplateVersion pulumi.StringOutput `pulumi:"templateVersion"`
	// Multi cluster app template version ID
	TemplateVersionId pulumi.StringOutput `pulumi:"templateVersionId"`
	// Multi cluster app upgrade strategy
	UpgradeStrategy MultiClusterAppUpgradeStrategyOutput `pulumi:"upgradeStrategy"`
	// Wait until multi cluster app is active
	Wait pulumi.BoolPtrOutput `pulumi:"wait"`
}

// NewMultiClusterApp registers a new resource with the given unique name, arguments, and options.
func NewMultiClusterApp(ctx *pulumi.Context,
	name string, args *MultiClusterAppArgs, opts ...pulumi.ResourceOption) (*MultiClusterApp, error) {
	if args == nil || args.CatalogName == nil {
		return nil, errors.New("missing required argument 'CatalogName'")
	}
	if args == nil || args.Roles == nil {
		return nil, errors.New("missing required argument 'Roles'")
	}
	if args == nil || args.Targets == nil {
		return nil, errors.New("missing required argument 'Targets'")
	}
	if args == nil || args.TemplateName == nil {
		return nil, errors.New("missing required argument 'TemplateName'")
	}
	if args == nil {
		args = &MultiClusterAppArgs{}
	}
	var resource MultiClusterApp
	err := ctx.RegisterResource("rancher2:index/multiClusterApp:MultiClusterApp", name, args, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// GetMultiClusterApp gets an existing MultiClusterApp resource's state with the given name, ID, and optional
// state properties that are used to uniquely qualify the lookup (nil if not required).
func GetMultiClusterApp(ctx *pulumi.Context,
	name string, id pulumi.IDInput, state *MultiClusterAppState, opts ...pulumi.ResourceOption) (*MultiClusterApp, error) {
	var resource MultiClusterApp
	err := ctx.ReadResource("rancher2:index/multiClusterApp:MultiClusterApp", name, id, state, &resource, opts...)
	if err != nil {
		return nil, err
	}
	return &resource, nil
}

// Input properties used for looking up and filtering MultiClusterApp resources.
type multiClusterAppState struct {
	// Annotations of the resource
	Annotations map[string]interface{} `pulumi:"annotations"`
	// Multi cluster app answers
	Answers []MultiClusterAppAnswer `pulumi:"answers"`
	// Multi cluster app catalog name
	CatalogName *string `pulumi:"catalogName"`
	// Labels of the resource
	Labels map[string]interface{} `pulumi:"labels"`
	// Multi cluster app members
	Members []MultiClusterAppMember `pulumi:"members"`
	// Multi cluster app name
	Name *string `pulumi:"name"`
	// Multi cluster app revision history limit
	RevisionHistoryLimit *int `pulumi:"revisionHistoryLimit"`
	// Multi cluster app revision name
	RevisionId *string `pulumi:"revisionId"`
	// Multi cluster app roles
	Roles []string `pulumi:"roles"`
	// Multi cluster app targets
	Targets []MultiClusterAppTarget `pulumi:"targets"`
	// Multi cluster app template name
	TemplateName *string `pulumi:"templateName"`
	// Multi cluster app template version
	TemplateVersion *string `pulumi:"templateVersion"`
	// Multi cluster app template version ID
	TemplateVersionId *string `pulumi:"templateVersionId"`
	// Multi cluster app upgrade strategy
	UpgradeStrategy *MultiClusterAppUpgradeStrategy `pulumi:"upgradeStrategy"`
	// Wait until multi cluster app is active
	Wait *bool `pulumi:"wait"`
}

type MultiClusterAppState struct {
	// Annotations of the resource
	Annotations pulumi.MapInput
	// Multi cluster app answers
	Answers MultiClusterAppAnswerArrayInput
	// Multi cluster app catalog name
	CatalogName pulumi.StringPtrInput
	// Labels of the resource
	Labels pulumi.MapInput
	// Multi cluster app members
	Members MultiClusterAppMemberArrayInput
	// Multi cluster app name
	Name pulumi.StringPtrInput
	// Multi cluster app revision history limit
	RevisionHistoryLimit pulumi.IntPtrInput
	// Multi cluster app revision name
	RevisionId pulumi.StringPtrInput
	// Multi cluster app roles
	Roles pulumi.StringArrayInput
	// Multi cluster app targets
	Targets MultiClusterAppTargetArrayInput
	// Multi cluster app template name
	TemplateName pulumi.StringPtrInput
	// Multi cluster app template version
	TemplateVersion pulumi.StringPtrInput
	// Multi cluster app template version ID
	TemplateVersionId pulumi.StringPtrInput
	// Multi cluster app upgrade strategy
	UpgradeStrategy MultiClusterAppUpgradeStrategyPtrInput
	// Wait until multi cluster app is active
	Wait pulumi.BoolPtrInput
}

func (MultiClusterAppState) ElementType() reflect.Type {
	return reflect.TypeOf((*multiClusterAppState)(nil)).Elem()
}

type multiClusterAppArgs struct {
	// Annotations of the resource
	Annotations map[string]interface{} `pulumi:"annotations"`
	// Multi cluster app answers
	Answers []MultiClusterAppAnswer `pulumi:"answers"`
	// Multi cluster app catalog name
	CatalogName string `pulumi:"catalogName"`
	// Labels of the resource
	Labels map[string]interface{} `pulumi:"labels"`
	// Multi cluster app members
	Members []MultiClusterAppMember `pulumi:"members"`
	// Multi cluster app name
	Name *string `pulumi:"name"`
	// Multi cluster app revision history limit
	RevisionHistoryLimit *int `pulumi:"revisionHistoryLimit"`
	// Multi cluster app revision name
	RevisionId *string `pulumi:"revisionId"`
	// Multi cluster app roles
	Roles []string `pulumi:"roles"`
	// Multi cluster app targets
	Targets []MultiClusterAppTarget `pulumi:"targets"`
	// Multi cluster app template name
	TemplateName string `pulumi:"templateName"`
	// Multi cluster app template version
	TemplateVersion *string `pulumi:"templateVersion"`
	// Multi cluster app upgrade strategy
	UpgradeStrategy *MultiClusterAppUpgradeStrategy `pulumi:"upgradeStrategy"`
	// Wait until multi cluster app is active
	Wait *bool `pulumi:"wait"`
}

// The set of arguments for constructing a MultiClusterApp resource.
type MultiClusterAppArgs struct {
	// Annotations of the resource
	Annotations pulumi.MapInput
	// Multi cluster app answers
	Answers MultiClusterAppAnswerArrayInput
	// Multi cluster app catalog name
	CatalogName pulumi.StringInput
	// Labels of the resource
	Labels pulumi.MapInput
	// Multi cluster app members
	Members MultiClusterAppMemberArrayInput
	// Multi cluster app name
	Name pulumi.StringPtrInput
	// Multi cluster app revision history limit
	RevisionHistoryLimit pulumi.IntPtrInput
	// Multi cluster app revision name
	RevisionId pulumi.StringPtrInput
	// Multi cluster app roles
	Roles pulumi.StringArrayInput
	// Multi cluster app targets
	Targets MultiClusterAppTargetArrayInput
	// Multi cluster app template name
	TemplateName pulumi.StringInput
	// Multi cluster app template version
	TemplateVersion pulumi.StringPtrInput
	// Multi cluster app upgrade strategy
	UpgradeStrategy MultiClusterAppUpgradeStrategyPtrInput
	// Wait until multi cluster app is active
	Wait pulumi.BoolPtrInput
}

func (MultiClusterAppArgs) ElementType() reflect.Type {
	return reflect.TypeOf((*multiClusterAppArgs)(nil)).Elem()
}
