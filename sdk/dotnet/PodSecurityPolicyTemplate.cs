// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

using System;
using System.Collections.Generic;
using System.Collections.Immutable;
using System.Threading.Tasks;
using Pulumi.Serialization;

namespace Pulumi.Rancher2
{
    public partial class PodSecurityPolicyTemplate : Pulumi.CustomResource
    {
        /// <summary>
        /// allowPrivilegeEscalation determines if a pod can request to allow privilege escalation. If unspecified, defaults to
        /// true.
        /// </summary>
        [Output("allowPrivilegeEscalation")]
        public Output<bool> AllowPrivilegeEscalation { get; private set; } = null!;

        /// <summary>
        /// allowedCapabilities is a list of capabilities that can be requested to add to the container. Capabilities in this field
        /// may be added at the pod author's discretion. You must not list a capability in both allowedCapabilities and
        /// requiredDropCapabilities.
        /// </summary>
        [Output("allowedCapabilities")]
        public Output<ImmutableArray<string>> AllowedCapabilities { get; private set; } = null!;

        /// <summary>
        /// AllowedCSIDrivers is a whitelist of inline CSI drivers that must be explicitly set to be embedded within a pod spec. An
        /// empty value indicates that any CSI driver can be used for inline ephemeral volumes. This is an alpha field, and is only
        /// honored if the API server enables the CSIInlineVolume feature gate.
        /// </summary>
        [Output("allowedCsiDrivers")]
        public Output<ImmutableArray<Outputs.PodSecurityPolicyTemplateAllowedCsiDriver>> AllowedCsiDrivers { get; private set; } = null!;

        /// <summary>
        /// allowedFlexVolumes is a whitelist of allowed Flexvolumes. Empty or nil indicates that all Flexvolumes may be used. This
        /// parameter is effective only when the usage of the Flexvolumes is allowed in the "volumes" field.
        /// </summary>
        [Output("allowedFlexVolumes")]
        public Output<ImmutableArray<Outputs.PodSecurityPolicyTemplateAllowedFlexVolume>> AllowedFlexVolumes { get; private set; } = null!;

        /// <summary>
        /// allowedHostPaths is a white list of allowed host paths. Empty indicates that all host paths may be used.
        /// </summary>
        [Output("allowedHostPaths")]
        public Output<ImmutableArray<Outputs.PodSecurityPolicyTemplateAllowedHostPath>> AllowedHostPaths { get; private set; } = null!;

        /// <summary>
        /// AllowedProcMountTypes is a whitelist of allowed ProcMountTypes. Empty or nil indicates that only the
        /// DefaultProcMountType may be used. This requires the ProcMountType feature flag to be enabled.
        /// </summary>
        [Output("allowedProcMountTypes")]
        public Output<ImmutableArray<string>> AllowedProcMountTypes { get; private set; } = null!;

        /// <summary>
        /// allowedUnsafeSysctls is a list of explicitly allowed unsafe sysctls, defaults to none. Each entry is either a plain
        /// sysctl name or ends in "*" in which case it is considered as a prefix of allowed sysctls. Single * means all unsafe
        /// sysctls are allowed. Kubelet has to whitelist all allowed unsafe sysctls explicitly to avoid rejection.
        /// </summary>
        [Output("allowedUnsafeSysctls")]
        public Output<ImmutableArray<string>> AllowedUnsafeSysctls { get; private set; } = null!;

        /// <summary>
        /// Annotations of the resource
        /// </summary>
        [Output("annotations")]
        public Output<ImmutableDictionary<string, object>> Annotations { get; private set; } = null!;

        /// <summary>
        /// defaultAddCapabilities is the default set of capabilities that will be added to the container unless the pod spec
        /// specifically drops the capability. You may not list a capability in both defaultAddCapabilities and
        /// requiredDropCapabilities. Capabilities added here are implicitly allowed, and need not be included in the
        /// allowedCapabilities list.
        /// </summary>
        [Output("defaultAddCapabilities")]
        public Output<ImmutableArray<string>> DefaultAddCapabilities { get; private set; } = null!;

        /// <summary>
        /// defaultAllowPrivilegeEscalation controls the default setting for whether a process can gain more privileges than its
        /// parent process.
        /// </summary>
        [Output("defaultAllowPrivilegeEscalation")]
        public Output<bool?> DefaultAllowPrivilegeEscalation { get; private set; } = null!;

        /// <summary>
        /// Pod Security Policy template policy description
        /// </summary>
        [Output("description")]
        public Output<string> Description { get; private set; } = null!;

        /// <summary>
        /// forbiddenSysctls is a list of explicitly forbidden sysctls, defaults to none. Each entry is either a plain sysctl name
        /// or ends in "*" in which case it is considered as a prefix of forbidden sysctls. Single * means all sysctls are
        /// forbidden.
        /// </summary>
        [Output("forbiddenSysctls")]
        public Output<ImmutableArray<string>> ForbiddenSysctls { get; private set; } = null!;

        /// <summary>
        /// fsGroup is the strategy that will dictate what fs group is used by the SecurityContext.
        /// </summary>
        [Output("fsGroup")]
        public Output<Outputs.PodSecurityPolicyTemplateFsGroup> FsGroup { get; private set; } = null!;

        /// <summary>
        /// hostIPC determines if the policy allows the use of HostIPC in the pod spec.
        /// </summary>
        [Output("hostIpc")]
        public Output<bool> HostIpc { get; private set; } = null!;

        /// <summary>
        /// hostNetwork determines if the policy allows the use of HostNetwork in the pod spec.
        /// </summary>
        [Output("hostNetwork")]
        public Output<bool> HostNetwork { get; private set; } = null!;

        /// <summary>
        /// hostPID determines if the policy allows the use of HostPID in the pod spec.
        /// </summary>
        [Output("hostPid")]
        public Output<bool> HostPid { get; private set; } = null!;

        /// <summary>
        /// hostPorts determines which host port ranges are allowed to be exposed.
        /// </summary>
        [Output("hostPorts")]
        public Output<ImmutableArray<Outputs.PodSecurityPolicyTemplateHostPort>> HostPorts { get; private set; } = null!;

        /// <summary>
        /// Labels of the resource
        /// </summary>
        [Output("labels")]
        public Output<ImmutableDictionary<string, object>> Labels { get; private set; } = null!;

        /// <summary>
        /// Pod Security Policy template policy name
        /// </summary>
        [Output("name")]
        public Output<string> Name { get; private set; } = null!;

        /// <summary>
        /// privileged determines if a pod can request to be run as privileged.
        /// </summary>
        [Output("privileged")]
        public Output<bool> Privileged { get; private set; } = null!;

        /// <summary>
        /// readOnlyRootFilesystem when set to true will force containers to run with a read only root file system. If the container
        /// specifically requests to run with a non-read only root file system the PSP should deny the pod. If set to false the
        /// container may run with a read only root file system if it wishes but it will not be forced to.
        /// </summary>
        [Output("readOnlyRootFilesystem")]
        public Output<bool> ReadOnlyRootFilesystem { get; private set; } = null!;

        /// <summary>
        /// requiredDropCapabilities are the capabilities that will be dropped from the container. These are required to be dropped
        /// and cannot be added.
        /// </summary>
        [Output("requiredDropCapabilities")]
        public Output<ImmutableArray<string>> RequiredDropCapabilities { get; private set; } = null!;

        /// <summary>
        /// RunAsGroup is the strategy that will dictate the allowable RunAsGroup values that may be set. If this field is omitted,
        /// the pod's RunAsGroup can take any value. This field requires the RunAsGroup feature gate to be enabled.
        /// </summary>
        [Output("runAsGroup")]
        public Output<Outputs.PodSecurityPolicyTemplateRunAsGroup?> RunAsGroup { get; private set; } = null!;

        /// <summary>
        /// runAsUser is the strategy that will dictate the allowable RunAsUser values that may be set.
        /// </summary>
        [Output("runAsUser")]
        public Output<Outputs.PodSecurityPolicyTemplateRunAsUser> RunAsUser { get; private set; } = null!;

        /// <summary>
        /// runtimeClass is the strategy that will dictate the allowable RuntimeClasses for a pod. If this field is omitted, the
        /// pod's runtimeClassName field is unrestricted. Enforcement of this field depends on the RuntimeClass feature gate being
        /// enabled.
        /// </summary>
        [Output("runtimeClass")]
        public Output<Outputs.PodSecurityPolicyTemplateRuntimeClass?> RuntimeClass { get; private set; } = null!;

        /// <summary>
        /// seLinux is the strategy that will dictate the allowable labels that may be set.
        /// </summary>
        [Output("seLinux")]
        public Output<Outputs.PodSecurityPolicyTemplateSeLinux> SeLinux { get; private set; } = null!;

        /// <summary>
        /// supplementalGroups is the strategy that will dictate what supplemental groups are used by the SecurityContext.
        /// </summary>
        [Output("supplementalGroup")]
        public Output<Outputs.PodSecurityPolicyTemplateSupplementalGroup> SupplementalGroup { get; private set; } = null!;

        /// <summary>
        /// volumes is a white list of allowed volume plugins. Empty indicates that no volumes may be used. To allow all volumes you
        /// may use '*'
        /// </summary>
        [Output("volumes")]
        public Output<ImmutableArray<string>> Volumes { get; private set; } = null!;


        /// <summary>
        /// Create a PodSecurityPolicyTemplate resource with the given unique name, arguments, and options.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resource</param>
        /// <param name="args">The arguments used to populate this resource's properties</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public PodSecurityPolicyTemplate(string name, PodSecurityPolicyTemplateArgs? args = null, CustomResourceOptions? options = null)
            : base("rancher2:index/podSecurityPolicyTemplate:PodSecurityPolicyTemplate", name, args ?? new PodSecurityPolicyTemplateArgs(), MakeResourceOptions(options, ""))
        {
        }

        private PodSecurityPolicyTemplate(string name, Input<string> id, PodSecurityPolicyTemplateState? state = null, CustomResourceOptions? options = null)
            : base("rancher2:index/podSecurityPolicyTemplate:PodSecurityPolicyTemplate", name, state, MakeResourceOptions(options, id))
        {
        }

        private static CustomResourceOptions MakeResourceOptions(CustomResourceOptions? options, Input<string>? id)
        {
            var defaultOptions = new CustomResourceOptions
            {
                Version = Utilities.Version,
            };
            var merged = CustomResourceOptions.Merge(defaultOptions, options);
            // Override the ID if one was specified for consistency with other language SDKs.
            merged.Id = id ?? merged.Id;
            return merged;
        }
        /// <summary>
        /// Get an existing PodSecurityPolicyTemplate resource's state with the given name, ID, and optional extra
        /// properties used to qualify the lookup.
        /// </summary>
        ///
        /// <param name="name">The unique name of the resulting resource.</param>
        /// <param name="id">The unique provider ID of the resource to lookup.</param>
        /// <param name="state">Any extra arguments used during the lookup.</param>
        /// <param name="options">A bag of options that control this resource's behavior</param>
        public static PodSecurityPolicyTemplate Get(string name, Input<string> id, PodSecurityPolicyTemplateState? state = null, CustomResourceOptions? options = null)
        {
            return new PodSecurityPolicyTemplate(name, id, state, options);
        }
    }

    public sealed class PodSecurityPolicyTemplateArgs : Pulumi.ResourceArgs
    {
        /// <summary>
        /// allowPrivilegeEscalation determines if a pod can request to allow privilege escalation. If unspecified, defaults to
        /// true.
        /// </summary>
        [Input("allowPrivilegeEscalation")]
        public Input<bool>? AllowPrivilegeEscalation { get; set; }

        [Input("allowedCapabilities")]
        private InputList<string>? _allowedCapabilities;

        /// <summary>
        /// allowedCapabilities is a list of capabilities that can be requested to add to the container. Capabilities in this field
        /// may be added at the pod author's discretion. You must not list a capability in both allowedCapabilities and
        /// requiredDropCapabilities.
        /// </summary>
        public InputList<string> AllowedCapabilities
        {
            get => _allowedCapabilities ?? (_allowedCapabilities = new InputList<string>());
            set => _allowedCapabilities = value;
        }

        [Input("allowedCsiDrivers")]
        private InputList<Inputs.PodSecurityPolicyTemplateAllowedCsiDriverArgs>? _allowedCsiDrivers;

        /// <summary>
        /// AllowedCSIDrivers is a whitelist of inline CSI drivers that must be explicitly set to be embedded within a pod spec. An
        /// empty value indicates that any CSI driver can be used for inline ephemeral volumes. This is an alpha field, and is only
        /// honored if the API server enables the CSIInlineVolume feature gate.
        /// </summary>
        public InputList<Inputs.PodSecurityPolicyTemplateAllowedCsiDriverArgs> AllowedCsiDrivers
        {
            get => _allowedCsiDrivers ?? (_allowedCsiDrivers = new InputList<Inputs.PodSecurityPolicyTemplateAllowedCsiDriverArgs>());
            set => _allowedCsiDrivers = value;
        }

        [Input("allowedFlexVolumes")]
        private InputList<Inputs.PodSecurityPolicyTemplateAllowedFlexVolumeArgs>? _allowedFlexVolumes;

        /// <summary>
        /// allowedFlexVolumes is a whitelist of allowed Flexvolumes. Empty or nil indicates that all Flexvolumes may be used. This
        /// parameter is effective only when the usage of the Flexvolumes is allowed in the "volumes" field.
        /// </summary>
        public InputList<Inputs.PodSecurityPolicyTemplateAllowedFlexVolumeArgs> AllowedFlexVolumes
        {
            get => _allowedFlexVolumes ?? (_allowedFlexVolumes = new InputList<Inputs.PodSecurityPolicyTemplateAllowedFlexVolumeArgs>());
            set => _allowedFlexVolumes = value;
        }

        [Input("allowedHostPaths")]
        private InputList<Inputs.PodSecurityPolicyTemplateAllowedHostPathArgs>? _allowedHostPaths;

        /// <summary>
        /// allowedHostPaths is a white list of allowed host paths. Empty indicates that all host paths may be used.
        /// </summary>
        public InputList<Inputs.PodSecurityPolicyTemplateAllowedHostPathArgs> AllowedHostPaths
        {
            get => _allowedHostPaths ?? (_allowedHostPaths = new InputList<Inputs.PodSecurityPolicyTemplateAllowedHostPathArgs>());
            set => _allowedHostPaths = value;
        }

        [Input("allowedProcMountTypes")]
        private InputList<string>? _allowedProcMountTypes;

        /// <summary>
        /// AllowedProcMountTypes is a whitelist of allowed ProcMountTypes. Empty or nil indicates that only the
        /// DefaultProcMountType may be used. This requires the ProcMountType feature flag to be enabled.
        /// </summary>
        public InputList<string> AllowedProcMountTypes
        {
            get => _allowedProcMountTypes ?? (_allowedProcMountTypes = new InputList<string>());
            set => _allowedProcMountTypes = value;
        }

        [Input("allowedUnsafeSysctls")]
        private InputList<string>? _allowedUnsafeSysctls;

        /// <summary>
        /// allowedUnsafeSysctls is a list of explicitly allowed unsafe sysctls, defaults to none. Each entry is either a plain
        /// sysctl name or ends in "*" in which case it is considered as a prefix of allowed sysctls. Single * means all unsafe
        /// sysctls are allowed. Kubelet has to whitelist all allowed unsafe sysctls explicitly to avoid rejection.
        /// </summary>
        public InputList<string> AllowedUnsafeSysctls
        {
            get => _allowedUnsafeSysctls ?? (_allowedUnsafeSysctls = new InputList<string>());
            set => _allowedUnsafeSysctls = value;
        }

        [Input("annotations")]
        private InputMap<object>? _annotations;

        /// <summary>
        /// Annotations of the resource
        /// </summary>
        public InputMap<object> Annotations
        {
            get => _annotations ?? (_annotations = new InputMap<object>());
            set => _annotations = value;
        }

        [Input("defaultAddCapabilities")]
        private InputList<string>? _defaultAddCapabilities;

        /// <summary>
        /// defaultAddCapabilities is the default set of capabilities that will be added to the container unless the pod spec
        /// specifically drops the capability. You may not list a capability in both defaultAddCapabilities and
        /// requiredDropCapabilities. Capabilities added here are implicitly allowed, and need not be included in the
        /// allowedCapabilities list.
        /// </summary>
        public InputList<string> DefaultAddCapabilities
        {
            get => _defaultAddCapabilities ?? (_defaultAddCapabilities = new InputList<string>());
            set => _defaultAddCapabilities = value;
        }

        /// <summary>
        /// defaultAllowPrivilegeEscalation controls the default setting for whether a process can gain more privileges than its
        /// parent process.
        /// </summary>
        [Input("defaultAllowPrivilegeEscalation")]
        public Input<bool>? DefaultAllowPrivilegeEscalation { get; set; }

        /// <summary>
        /// Pod Security Policy template policy description
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        [Input("forbiddenSysctls")]
        private InputList<string>? _forbiddenSysctls;

        /// <summary>
        /// forbiddenSysctls is a list of explicitly forbidden sysctls, defaults to none. Each entry is either a plain sysctl name
        /// or ends in "*" in which case it is considered as a prefix of forbidden sysctls. Single * means all sysctls are
        /// forbidden.
        /// </summary>
        public InputList<string> ForbiddenSysctls
        {
            get => _forbiddenSysctls ?? (_forbiddenSysctls = new InputList<string>());
            set => _forbiddenSysctls = value;
        }

        /// <summary>
        /// fsGroup is the strategy that will dictate what fs group is used by the SecurityContext.
        /// </summary>
        [Input("fsGroup")]
        public Input<Inputs.PodSecurityPolicyTemplateFsGroupArgs>? FsGroup { get; set; }

        /// <summary>
        /// hostIPC determines if the policy allows the use of HostIPC in the pod spec.
        /// </summary>
        [Input("hostIpc")]
        public Input<bool>? HostIpc { get; set; }

        /// <summary>
        /// hostNetwork determines if the policy allows the use of HostNetwork in the pod spec.
        /// </summary>
        [Input("hostNetwork")]
        public Input<bool>? HostNetwork { get; set; }

        /// <summary>
        /// hostPID determines if the policy allows the use of HostPID in the pod spec.
        /// </summary>
        [Input("hostPid")]
        public Input<bool>? HostPid { get; set; }

        [Input("hostPorts")]
        private InputList<Inputs.PodSecurityPolicyTemplateHostPortArgs>? _hostPorts;

        /// <summary>
        /// hostPorts determines which host port ranges are allowed to be exposed.
        /// </summary>
        public InputList<Inputs.PodSecurityPolicyTemplateHostPortArgs> HostPorts
        {
            get => _hostPorts ?? (_hostPorts = new InputList<Inputs.PodSecurityPolicyTemplateHostPortArgs>());
            set => _hostPorts = value;
        }

        [Input("labels")]
        private InputMap<object>? _labels;

        /// <summary>
        /// Labels of the resource
        /// </summary>
        public InputMap<object> Labels
        {
            get => _labels ?? (_labels = new InputMap<object>());
            set => _labels = value;
        }

        /// <summary>
        /// Pod Security Policy template policy name
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// privileged determines if a pod can request to be run as privileged.
        /// </summary>
        [Input("privileged")]
        public Input<bool>? Privileged { get; set; }

        /// <summary>
        /// readOnlyRootFilesystem when set to true will force containers to run with a read only root file system. If the container
        /// specifically requests to run with a non-read only root file system the PSP should deny the pod. If set to false the
        /// container may run with a read only root file system if it wishes but it will not be forced to.
        /// </summary>
        [Input("readOnlyRootFilesystem")]
        public Input<bool>? ReadOnlyRootFilesystem { get; set; }

        [Input("requiredDropCapabilities")]
        private InputList<string>? _requiredDropCapabilities;

        /// <summary>
        /// requiredDropCapabilities are the capabilities that will be dropped from the container. These are required to be dropped
        /// and cannot be added.
        /// </summary>
        public InputList<string> RequiredDropCapabilities
        {
            get => _requiredDropCapabilities ?? (_requiredDropCapabilities = new InputList<string>());
            set => _requiredDropCapabilities = value;
        }

        /// <summary>
        /// RunAsGroup is the strategy that will dictate the allowable RunAsGroup values that may be set. If this field is omitted,
        /// the pod's RunAsGroup can take any value. This field requires the RunAsGroup feature gate to be enabled.
        /// </summary>
        [Input("runAsGroup")]
        public Input<Inputs.PodSecurityPolicyTemplateRunAsGroupArgs>? RunAsGroup { get; set; }

        /// <summary>
        /// runAsUser is the strategy that will dictate the allowable RunAsUser values that may be set.
        /// </summary>
        [Input("runAsUser")]
        public Input<Inputs.PodSecurityPolicyTemplateRunAsUserArgs>? RunAsUser { get; set; }

        /// <summary>
        /// runtimeClass is the strategy that will dictate the allowable RuntimeClasses for a pod. If this field is omitted, the
        /// pod's runtimeClassName field is unrestricted. Enforcement of this field depends on the RuntimeClass feature gate being
        /// enabled.
        /// </summary>
        [Input("runtimeClass")]
        public Input<Inputs.PodSecurityPolicyTemplateRuntimeClassArgs>? RuntimeClass { get; set; }

        /// <summary>
        /// seLinux is the strategy that will dictate the allowable labels that may be set.
        /// </summary>
        [Input("seLinux")]
        public Input<Inputs.PodSecurityPolicyTemplateSeLinuxArgs>? SeLinux { get; set; }

        /// <summary>
        /// supplementalGroups is the strategy that will dictate what supplemental groups are used by the SecurityContext.
        /// </summary>
        [Input("supplementalGroup")]
        public Input<Inputs.PodSecurityPolicyTemplateSupplementalGroupArgs>? SupplementalGroup { get; set; }

        [Input("volumes")]
        private InputList<string>? _volumes;

        /// <summary>
        /// volumes is a white list of allowed volume plugins. Empty indicates that no volumes may be used. To allow all volumes you
        /// may use '*'
        /// </summary>
        public InputList<string> Volumes
        {
            get => _volumes ?? (_volumes = new InputList<string>());
            set => _volumes = value;
        }

        public PodSecurityPolicyTemplateArgs()
        {
        }
    }

    public sealed class PodSecurityPolicyTemplateState : Pulumi.ResourceArgs
    {
        /// <summary>
        /// allowPrivilegeEscalation determines if a pod can request to allow privilege escalation. If unspecified, defaults to
        /// true.
        /// </summary>
        [Input("allowPrivilegeEscalation")]
        public Input<bool>? AllowPrivilegeEscalation { get; set; }

        [Input("allowedCapabilities")]
        private InputList<string>? _allowedCapabilities;

        /// <summary>
        /// allowedCapabilities is a list of capabilities that can be requested to add to the container. Capabilities in this field
        /// may be added at the pod author's discretion. You must not list a capability in both allowedCapabilities and
        /// requiredDropCapabilities.
        /// </summary>
        public InputList<string> AllowedCapabilities
        {
            get => _allowedCapabilities ?? (_allowedCapabilities = new InputList<string>());
            set => _allowedCapabilities = value;
        }

        [Input("allowedCsiDrivers")]
        private InputList<Inputs.PodSecurityPolicyTemplateAllowedCsiDriverGetArgs>? _allowedCsiDrivers;

        /// <summary>
        /// AllowedCSIDrivers is a whitelist of inline CSI drivers that must be explicitly set to be embedded within a pod spec. An
        /// empty value indicates that any CSI driver can be used for inline ephemeral volumes. This is an alpha field, and is only
        /// honored if the API server enables the CSIInlineVolume feature gate.
        /// </summary>
        public InputList<Inputs.PodSecurityPolicyTemplateAllowedCsiDriverGetArgs> AllowedCsiDrivers
        {
            get => _allowedCsiDrivers ?? (_allowedCsiDrivers = new InputList<Inputs.PodSecurityPolicyTemplateAllowedCsiDriverGetArgs>());
            set => _allowedCsiDrivers = value;
        }

        [Input("allowedFlexVolumes")]
        private InputList<Inputs.PodSecurityPolicyTemplateAllowedFlexVolumeGetArgs>? _allowedFlexVolumes;

        /// <summary>
        /// allowedFlexVolumes is a whitelist of allowed Flexvolumes. Empty or nil indicates that all Flexvolumes may be used. This
        /// parameter is effective only when the usage of the Flexvolumes is allowed in the "volumes" field.
        /// </summary>
        public InputList<Inputs.PodSecurityPolicyTemplateAllowedFlexVolumeGetArgs> AllowedFlexVolumes
        {
            get => _allowedFlexVolumes ?? (_allowedFlexVolumes = new InputList<Inputs.PodSecurityPolicyTemplateAllowedFlexVolumeGetArgs>());
            set => _allowedFlexVolumes = value;
        }

        [Input("allowedHostPaths")]
        private InputList<Inputs.PodSecurityPolicyTemplateAllowedHostPathGetArgs>? _allowedHostPaths;

        /// <summary>
        /// allowedHostPaths is a white list of allowed host paths. Empty indicates that all host paths may be used.
        /// </summary>
        public InputList<Inputs.PodSecurityPolicyTemplateAllowedHostPathGetArgs> AllowedHostPaths
        {
            get => _allowedHostPaths ?? (_allowedHostPaths = new InputList<Inputs.PodSecurityPolicyTemplateAllowedHostPathGetArgs>());
            set => _allowedHostPaths = value;
        }

        [Input("allowedProcMountTypes")]
        private InputList<string>? _allowedProcMountTypes;

        /// <summary>
        /// AllowedProcMountTypes is a whitelist of allowed ProcMountTypes. Empty or nil indicates that only the
        /// DefaultProcMountType may be used. This requires the ProcMountType feature flag to be enabled.
        /// </summary>
        public InputList<string> AllowedProcMountTypes
        {
            get => _allowedProcMountTypes ?? (_allowedProcMountTypes = new InputList<string>());
            set => _allowedProcMountTypes = value;
        }

        [Input("allowedUnsafeSysctls")]
        private InputList<string>? _allowedUnsafeSysctls;

        /// <summary>
        /// allowedUnsafeSysctls is a list of explicitly allowed unsafe sysctls, defaults to none. Each entry is either a plain
        /// sysctl name or ends in "*" in which case it is considered as a prefix of allowed sysctls. Single * means all unsafe
        /// sysctls are allowed. Kubelet has to whitelist all allowed unsafe sysctls explicitly to avoid rejection.
        /// </summary>
        public InputList<string> AllowedUnsafeSysctls
        {
            get => _allowedUnsafeSysctls ?? (_allowedUnsafeSysctls = new InputList<string>());
            set => _allowedUnsafeSysctls = value;
        }

        [Input("annotations")]
        private InputMap<object>? _annotations;

        /// <summary>
        /// Annotations of the resource
        /// </summary>
        public InputMap<object> Annotations
        {
            get => _annotations ?? (_annotations = new InputMap<object>());
            set => _annotations = value;
        }

        [Input("defaultAddCapabilities")]
        private InputList<string>? _defaultAddCapabilities;

        /// <summary>
        /// defaultAddCapabilities is the default set of capabilities that will be added to the container unless the pod spec
        /// specifically drops the capability. You may not list a capability in both defaultAddCapabilities and
        /// requiredDropCapabilities. Capabilities added here are implicitly allowed, and need not be included in the
        /// allowedCapabilities list.
        /// </summary>
        public InputList<string> DefaultAddCapabilities
        {
            get => _defaultAddCapabilities ?? (_defaultAddCapabilities = new InputList<string>());
            set => _defaultAddCapabilities = value;
        }

        /// <summary>
        /// defaultAllowPrivilegeEscalation controls the default setting for whether a process can gain more privileges than its
        /// parent process.
        /// </summary>
        [Input("defaultAllowPrivilegeEscalation")]
        public Input<bool>? DefaultAllowPrivilegeEscalation { get; set; }

        /// <summary>
        /// Pod Security Policy template policy description
        /// </summary>
        [Input("description")]
        public Input<string>? Description { get; set; }

        [Input("forbiddenSysctls")]
        private InputList<string>? _forbiddenSysctls;

        /// <summary>
        /// forbiddenSysctls is a list of explicitly forbidden sysctls, defaults to none. Each entry is either a plain sysctl name
        /// or ends in "*" in which case it is considered as a prefix of forbidden sysctls. Single * means all sysctls are
        /// forbidden.
        /// </summary>
        public InputList<string> ForbiddenSysctls
        {
            get => _forbiddenSysctls ?? (_forbiddenSysctls = new InputList<string>());
            set => _forbiddenSysctls = value;
        }

        /// <summary>
        /// fsGroup is the strategy that will dictate what fs group is used by the SecurityContext.
        /// </summary>
        [Input("fsGroup")]
        public Input<Inputs.PodSecurityPolicyTemplateFsGroupGetArgs>? FsGroup { get; set; }

        /// <summary>
        /// hostIPC determines if the policy allows the use of HostIPC in the pod spec.
        /// </summary>
        [Input("hostIpc")]
        public Input<bool>? HostIpc { get; set; }

        /// <summary>
        /// hostNetwork determines if the policy allows the use of HostNetwork in the pod spec.
        /// </summary>
        [Input("hostNetwork")]
        public Input<bool>? HostNetwork { get; set; }

        /// <summary>
        /// hostPID determines if the policy allows the use of HostPID in the pod spec.
        /// </summary>
        [Input("hostPid")]
        public Input<bool>? HostPid { get; set; }

        [Input("hostPorts")]
        private InputList<Inputs.PodSecurityPolicyTemplateHostPortGetArgs>? _hostPorts;

        /// <summary>
        /// hostPorts determines which host port ranges are allowed to be exposed.
        /// </summary>
        public InputList<Inputs.PodSecurityPolicyTemplateHostPortGetArgs> HostPorts
        {
            get => _hostPorts ?? (_hostPorts = new InputList<Inputs.PodSecurityPolicyTemplateHostPortGetArgs>());
            set => _hostPorts = value;
        }

        [Input("labels")]
        private InputMap<object>? _labels;

        /// <summary>
        /// Labels of the resource
        /// </summary>
        public InputMap<object> Labels
        {
            get => _labels ?? (_labels = new InputMap<object>());
            set => _labels = value;
        }

        /// <summary>
        /// Pod Security Policy template policy name
        /// </summary>
        [Input("name")]
        public Input<string>? Name { get; set; }

        /// <summary>
        /// privileged determines if a pod can request to be run as privileged.
        /// </summary>
        [Input("privileged")]
        public Input<bool>? Privileged { get; set; }

        /// <summary>
        /// readOnlyRootFilesystem when set to true will force containers to run with a read only root file system. If the container
        /// specifically requests to run with a non-read only root file system the PSP should deny the pod. If set to false the
        /// container may run with a read only root file system if it wishes but it will not be forced to.
        /// </summary>
        [Input("readOnlyRootFilesystem")]
        public Input<bool>? ReadOnlyRootFilesystem { get; set; }

        [Input("requiredDropCapabilities")]
        private InputList<string>? _requiredDropCapabilities;

        /// <summary>
        /// requiredDropCapabilities are the capabilities that will be dropped from the container. These are required to be dropped
        /// and cannot be added.
        /// </summary>
        public InputList<string> RequiredDropCapabilities
        {
            get => _requiredDropCapabilities ?? (_requiredDropCapabilities = new InputList<string>());
            set => _requiredDropCapabilities = value;
        }

        /// <summary>
        /// RunAsGroup is the strategy that will dictate the allowable RunAsGroup values that may be set. If this field is omitted,
        /// the pod's RunAsGroup can take any value. This field requires the RunAsGroup feature gate to be enabled.
        /// </summary>
        [Input("runAsGroup")]
        public Input<Inputs.PodSecurityPolicyTemplateRunAsGroupGetArgs>? RunAsGroup { get; set; }

        /// <summary>
        /// runAsUser is the strategy that will dictate the allowable RunAsUser values that may be set.
        /// </summary>
        [Input("runAsUser")]
        public Input<Inputs.PodSecurityPolicyTemplateRunAsUserGetArgs>? RunAsUser { get; set; }

        /// <summary>
        /// runtimeClass is the strategy that will dictate the allowable RuntimeClasses for a pod. If this field is omitted, the
        /// pod's runtimeClassName field is unrestricted. Enforcement of this field depends on the RuntimeClass feature gate being
        /// enabled.
        /// </summary>
        [Input("runtimeClass")]
        public Input<Inputs.PodSecurityPolicyTemplateRuntimeClassGetArgs>? RuntimeClass { get; set; }

        /// <summary>
        /// seLinux is the strategy that will dictate the allowable labels that may be set.
        /// </summary>
        [Input("seLinux")]
        public Input<Inputs.PodSecurityPolicyTemplateSeLinuxGetArgs>? SeLinux { get; set; }

        /// <summary>
        /// supplementalGroups is the strategy that will dictate what supplemental groups are used by the SecurityContext.
        /// </summary>
        [Input("supplementalGroup")]
        public Input<Inputs.PodSecurityPolicyTemplateSupplementalGroupGetArgs>? SupplementalGroup { get; set; }

        [Input("volumes")]
        private InputList<string>? _volumes;

        /// <summary>
        /// volumes is a white list of allowed volume plugins. Empty indicates that no volumes may be used. To allow all volumes you
        /// may use '*'
        /// </summary>
        public InputList<string> Volumes
        {
            get => _volumes ?? (_volumes = new InputList<string>());
            set => _volumes = value;
        }

        public PodSecurityPolicyTemplateState()
        {
        }
    }
}
