// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface CloudCredentialAmazonec2CredentialConfig {
    accessKey: pulumi.Input<string>;
    secretKey: pulumi.Input<string>;
}

export interface CloudCredentialAzureCredentialConfig {
    clientId: pulumi.Input<string>;
    clientSecret: pulumi.Input<string>;
    subscriptionId: pulumi.Input<string>;
}

export interface CloudCredentialDigitaloceanCredentialConfig {
    accessToken: pulumi.Input<string>;
}

export interface CloudCredentialLinodeCredentialConfig {
    token: pulumi.Input<string>;
}

export interface CloudCredentialOpenstackCredentialConfig {
    password: pulumi.Input<string>;
}

export interface CloudCredentialVsphereCredentialConfig {
    password: pulumi.Input<string>;
    username: pulumi.Input<string>;
    vcenter: pulumi.Input<string>;
    vcenterPort?: pulumi.Input<string>;
}

export interface ClusterAksConfig {
    aadServerAppSecret?: pulumi.Input<string>;
    aadTenantId?: pulumi.Input<string>;
    addClientAppId?: pulumi.Input<string>;
    addServerAppId?: pulumi.Input<string>;
    adminUsername?: pulumi.Input<string>;
    agentDnsPrefix: pulumi.Input<string>;
    agentOsDiskSize?: pulumi.Input<number>;
    agentPoolName?: pulumi.Input<string>;
    agentStorageProfile?: pulumi.Input<string>;
    agentVmSize?: pulumi.Input<string>;
    authBaseUrl?: pulumi.Input<string>;
    baseUrl?: pulumi.Input<string>;
    clientId: pulumi.Input<string>;
    clientSecret: pulumi.Input<string>;
    count?: pulumi.Input<number>;
    dnsServiceIp?: pulumi.Input<string>;
    dockerBridgeCidr?: pulumi.Input<string>;
    enableHttpApplicationRouting?: pulumi.Input<boolean>;
    enableMonitoring?: pulumi.Input<boolean>;
    kubernetesVersion: pulumi.Input<string>;
    location?: pulumi.Input<string>;
    logAnalyticsWorkspace?: pulumi.Input<string>;
    logAnalyticsWorkspaceResourceGroup?: pulumi.Input<string>;
    masterDnsPrefix: pulumi.Input<string>;
    maxPods?: pulumi.Input<number>;
    networkPlugin?: pulumi.Input<string>;
    networkPolicy?: pulumi.Input<string>;
    podCidr?: pulumi.Input<string>;
    resourceGroup: pulumi.Input<string>;
    serviceCidr?: pulumi.Input<string>;
    sshPublicKeyContents: pulumi.Input<string>;
    subnet: pulumi.Input<string>;
    subscriptionId: pulumi.Input<string>;
    tag?: pulumi.Input<{[key: string]: any}>;
    tenantId: pulumi.Input<string>;
    virtualNetwork: pulumi.Input<string>;
    virtualNetworkResourceGroup: pulumi.Input<string>;
}

export interface ClusterAlertGroupRecipient {
    defaultRecipient?: pulumi.Input<boolean>;
    notifierId: pulumi.Input<string>;
    notifierType?: pulumi.Input<string>;
    recipient?: pulumi.Input<string>;
}

export interface ClusterAlertRuleEventRule {
    eventType?: pulumi.Input<string>;
    resourceKind: pulumi.Input<string>;
}

export interface ClusterAlertRuleMetricRule {
    comparison?: pulumi.Input<string>;
    description?: pulumi.Input<string>;
    duration: pulumi.Input<string>;
    expression: pulumi.Input<string>;
    thresholdValue: pulumi.Input<number>;
}

export interface ClusterAlertRuleNodeRule {
    condition?: pulumi.Input<string>;
    cpuThreshold?: pulumi.Input<number>;
    memThreshold?: pulumi.Input<number>;
    nodeId?: pulumi.Input<string>;
    selector?: pulumi.Input<{[key: string]: any}>;
}

export interface ClusterAlertRuleSystemServiceRule {
    condition?: pulumi.Input<string>;
}

export interface ClusterAlterGroupRecipient {
    defaultRecipient?: pulumi.Input<boolean>;
    notifierId: pulumi.Input<string>;
    notifierType?: pulumi.Input<string>;
    recipient?: pulumi.Input<string>;
}

export interface ClusterAlterRuleEventRule {
    eventType?: pulumi.Input<string>;
    resourceKind: pulumi.Input<string>;
}

export interface ClusterAlterRuleMetricRule {
    comparison?: pulumi.Input<string>;
    description?: pulumi.Input<string>;
    duration: pulumi.Input<string>;
    expression: pulumi.Input<string>;
    thresholdValue: pulumi.Input<number>;
}

export interface ClusterAlterRuleNodeRule {
    condition?: pulumi.Input<string>;
    cpuThreshold?: pulumi.Input<number>;
    memThreshold?: pulumi.Input<number>;
    nodeId?: pulumi.Input<string>;
    selector?: pulumi.Input<{[key: string]: any}>;
}

export interface ClusterAlterRuleSystemServiceRule {
    condition?: pulumi.Input<string>;
}

export interface ClusterClusterAuthEndpoint {
    caCerts?: pulumi.Input<string>;
    enabled?: pulumi.Input<boolean>;
    fqdn?: pulumi.Input<string>;
}

export interface ClusterClusterMonitoringInput {
    answers?: pulumi.Input<{[key: string]: any}>;
    version?: pulumi.Input<string>;
}

export interface ClusterClusterRegistrationToken {
    annotations?: pulumi.Input<{[key: string]: any}>;
    clusterId?: pulumi.Input<string>;
    command?: pulumi.Input<string>;
    id?: pulumi.Input<string>;
    insecureCommand?: pulumi.Input<string>;
    labels?: pulumi.Input<{[key: string]: any}>;
    manifestUrl?: pulumi.Input<string>;
    name?: pulumi.Input<string>;
    nodeCommand?: pulumi.Input<string>;
    token?: pulumi.Input<string>;
    windowsNodeCommand?: pulumi.Input<string>;
}

export interface ClusterClusterTemplateAnswers {
    clusterId?: pulumi.Input<string>;
    projectId?: pulumi.Input<string>;
    values?: pulumi.Input<{[key: string]: any}>;
}

export interface ClusterClusterTemplateQuestion {
    default: pulumi.Input<string>;
    required?: pulumi.Input<boolean>;
    type?: pulumi.Input<string>;
    variable: pulumi.Input<string>;
}

export interface ClusterEksConfig {
    accessKey: pulumi.Input<string>;
    ami?: pulumi.Input<string>;
    associateWorkerNodePublicIp?: pulumi.Input<boolean>;
    desiredNodes?: pulumi.Input<number>;
    instanceType?: pulumi.Input<string>;
    keyPairName?: pulumi.Input<string>;
    kubernetesVersion: pulumi.Input<string>;
    maximumNodes?: pulumi.Input<number>;
    minimumNodes?: pulumi.Input<number>;
    nodeVolumeSize?: pulumi.Input<number>;
    region?: pulumi.Input<string>;
    secretKey: pulumi.Input<string>;
    securityGroups?: pulumi.Input<pulumi.Input<string>[]>;
    serviceRole?: pulumi.Input<string>;
    sessionToken?: pulumi.Input<string>;
    subnets?: pulumi.Input<pulumi.Input<string>[]>;
    userData?: pulumi.Input<string>;
    virtualNetwork?: pulumi.Input<string>;
}

export interface ClusterGkeConfig {
    clusterIpv4Cidr: pulumi.Input<string>;
    credential: pulumi.Input<string>;
    description?: pulumi.Input<string>;
    diskSizeGb?: pulumi.Input<number>;
    diskType: pulumi.Input<string>;
    enableAlphaFeature?: pulumi.Input<boolean>;
    enableAutoRepair?: pulumi.Input<boolean>;
    enableAutoUpgrade?: pulumi.Input<boolean>;
    enableHorizontalPodAutoscaling?: pulumi.Input<boolean>;
    enableHttpLoadBalancing?: pulumi.Input<boolean>;
    enableKubernetesDashboard?: pulumi.Input<boolean>;
    enableLegacyAbac?: pulumi.Input<boolean>;
    enableMasterAuthorizedNetwork?: pulumi.Input<boolean>;
    enableNetworkPolicyConfig?: pulumi.Input<boolean>;
    enableNodepoolAutoscaling?: pulumi.Input<boolean>;
    enablePrivateEndpoint?: pulumi.Input<boolean>;
    enablePrivateNodes?: pulumi.Input<boolean>;
    enableStackdriverLogging?: pulumi.Input<boolean>;
    enableStackdriverMonitoring?: pulumi.Input<boolean>;
    imageType: pulumi.Input<string>;
    ipPolicyClusterIpv4CidrBlock: pulumi.Input<string>;
    ipPolicyClusterSecondaryRangeName: pulumi.Input<string>;
    ipPolicyCreateSubnetwork?: pulumi.Input<boolean>;
    ipPolicyNodeIpv4CidrBlock: pulumi.Input<string>;
    ipPolicyServicesIpv4CidrBlock: pulumi.Input<string>;
    ipPolicyServicesSecondaryRangeName: pulumi.Input<string>;
    ipPolicySubnetworkName: pulumi.Input<string>;
    issueClientCertificate?: pulumi.Input<boolean>;
    kubernetesDashboard?: pulumi.Input<boolean>;
    labels?: pulumi.Input<{[key: string]: any}>;
    localSsdCount?: pulumi.Input<number>;
    locations: pulumi.Input<pulumi.Input<string>[]>;
    machineType: pulumi.Input<string>;
    maintenanceWindow: pulumi.Input<string>;
    masterAuthorizedNetworkCidrBlocks?: pulumi.Input<pulumi.Input<string>[]>;
    masterIpv4CidrBlock: pulumi.Input<string>;
    masterVersion: pulumi.Input<string>;
    maxNodeCount?: pulumi.Input<number>;
    minNodeCount?: pulumi.Input<number>;
    network: pulumi.Input<string>;
    nodeCount?: pulumi.Input<number>;
    nodePool: pulumi.Input<string>;
    nodeVersion: pulumi.Input<string>;
    oauthScopes: pulumi.Input<pulumi.Input<string>[]>;
    preemptible?: pulumi.Input<boolean>;
    projectId: pulumi.Input<string>;
    region?: pulumi.Input<string>;
    resourceLabels?: pulumi.Input<{[key: string]: any}>;
    serviceAccount: pulumi.Input<string>;
    subNetwork: pulumi.Input<string>;
    taints?: pulumi.Input<pulumi.Input<string>[]>;
    useIpAliases?: pulumi.Input<boolean>;
    zone?: pulumi.Input<string>;
}

export interface ClusterK3sConfig {
    upgradeStrategy?: pulumi.Input<inputs.ClusterK3sConfigUpgradeStrategy>;
    version?: pulumi.Input<string>;
}

export interface ClusterK3sConfigUpgradeStrategy {
    drainServerNodes?: pulumi.Input<boolean>;
    drainWorkerNodes?: pulumi.Input<boolean>;
    serverConcurrency?: pulumi.Input<number>;
    workerConcurrency?: pulumi.Input<number>;
}

export interface ClusterLoggingCustomTargetConfig {
    certificate?: pulumi.Input<string>;
    clientCert?: pulumi.Input<string>;
    clientKey?: pulumi.Input<string>;
    content: pulumi.Input<string>;
}

export interface ClusterLoggingElasticsearchConfig {
    authPassword?: pulumi.Input<string>;
    authUsername?: pulumi.Input<string>;
    certificate?: pulumi.Input<string>;
    clientCert?: pulumi.Input<string>;
    clientKey?: pulumi.Input<string>;
    clientKeyPass?: pulumi.Input<string>;
    dateFormat?: pulumi.Input<string>;
    endpoint: pulumi.Input<string>;
    indexPrefix?: pulumi.Input<string>;
    sslVerify?: pulumi.Input<boolean>;
    sslVersion?: pulumi.Input<string>;
}

export interface ClusterLoggingFluentdConfig {
    certificate?: pulumi.Input<string>;
    compress?: pulumi.Input<boolean>;
    enableTls?: pulumi.Input<boolean>;
    fluentServers: pulumi.Input<pulumi.Input<inputs.ClusterLoggingFluentdConfigFluentServer>[]>;
}

export interface ClusterLoggingFluentdConfigFluentServer {
    endpoint: pulumi.Input<string>;
    hostname?: pulumi.Input<string>;
    password?: pulumi.Input<string>;
    sharedKey?: pulumi.Input<string>;
    standby?: pulumi.Input<boolean>;
    username?: pulumi.Input<string>;
    weight?: pulumi.Input<number>;
}

export interface ClusterLoggingKafkaConfig {
    brokerEndpoints?: pulumi.Input<pulumi.Input<string>[]>;
    certificate?: pulumi.Input<string>;
    clientCert?: pulumi.Input<string>;
    clientKey?: pulumi.Input<string>;
    topic: pulumi.Input<string>;
    zookeeperEndpoint?: pulumi.Input<string>;
}

export interface ClusterLoggingSplunkConfig {
    certificate?: pulumi.Input<string>;
    clientCert?: pulumi.Input<string>;
    clientKey?: pulumi.Input<string>;
    clientKeyPass?: pulumi.Input<string>;
    endpoint: pulumi.Input<string>;
    index?: pulumi.Input<string>;
    source?: pulumi.Input<string>;
    sslVerify?: pulumi.Input<boolean>;
    token: pulumi.Input<string>;
}

export interface ClusterLoggingSyslogConfig {
    certificate?: pulumi.Input<string>;
    clientCert?: pulumi.Input<string>;
    clientKey?: pulumi.Input<string>;
    enableTls?: pulumi.Input<boolean>;
    endpoint: pulumi.Input<string>;
    program?: pulumi.Input<string>;
    protocol?: pulumi.Input<string>;
    severity?: pulumi.Input<string>;
    sslVerify?: pulumi.Input<boolean>;
    token?: pulumi.Input<string>;
}

export interface ClusterRkeConfig {
    addonJobTimeout?: pulumi.Input<number>;
    addons?: pulumi.Input<string>;
    addonsIncludes?: pulumi.Input<pulumi.Input<string>[]>;
    authentication?: pulumi.Input<inputs.ClusterRkeConfigAuthentication>;
    authorization?: pulumi.Input<inputs.ClusterRkeConfigAuthorization>;
    bastionHost?: pulumi.Input<inputs.ClusterRkeConfigBastionHost>;
    cloudProvider?: pulumi.Input<inputs.ClusterRkeConfigCloudProvider>;
    dns?: pulumi.Input<inputs.ClusterRkeConfigDns>;
    ignoreDockerVersion?: pulumi.Input<boolean>;
    ingress?: pulumi.Input<inputs.ClusterRkeConfigIngress>;
    kubernetesVersion?: pulumi.Input<string>;
    monitoring?: pulumi.Input<inputs.ClusterRkeConfigMonitoring>;
    network?: pulumi.Input<inputs.ClusterRkeConfigNetwork>;
    nodes?: pulumi.Input<pulumi.Input<inputs.ClusterRkeConfigNode>[]>;
    prefixPath?: pulumi.Input<string>;
    privateRegistries?: pulumi.Input<pulumi.Input<inputs.ClusterRkeConfigPrivateRegistry>[]>;
    services?: pulumi.Input<inputs.ClusterRkeConfigServices>;
    sshAgentAuth?: pulumi.Input<boolean>;
    sshCertPath?: pulumi.Input<string>;
    sshKeyPath?: pulumi.Input<string>;
    upgradeStrategy?: pulumi.Input<inputs.ClusterRkeConfigUpgradeStrategy>;
}

export interface ClusterRkeConfigAuthentication {
    sans?: pulumi.Input<pulumi.Input<string>[]>;
    strategy?: pulumi.Input<string>;
}

export interface ClusterRkeConfigAuthorization {
    mode?: pulumi.Input<string>;
    options?: pulumi.Input<{[key: string]: any}>;
}

export interface ClusterRkeConfigBastionHost {
    address: pulumi.Input<string>;
    port?: pulumi.Input<string>;
    sshAgentAuth?: pulumi.Input<boolean>;
    sshKey?: pulumi.Input<string>;
    sshKeyPath?: pulumi.Input<string>;
    user: pulumi.Input<string>;
}

export interface ClusterRkeConfigCloudProvider {
    awsCloudProvider?: pulumi.Input<inputs.ClusterRkeConfigCloudProviderAwsCloudProvider>;
    azureCloudProvider?: pulumi.Input<inputs.ClusterRkeConfigCloudProviderAzureCloudProvider>;
    customCloudProvider?: pulumi.Input<string>;
    name?: pulumi.Input<string>;
    openstackCloudProvider?: pulumi.Input<inputs.ClusterRkeConfigCloudProviderOpenstackCloudProvider>;
    vsphereCloudProvider?: pulumi.Input<inputs.ClusterRkeConfigCloudProviderVsphereCloudProvider>;
}

export interface ClusterRkeConfigCloudProviderAwsCloudProvider {
    global?: pulumi.Input<inputs.ClusterRkeConfigCloudProviderAwsCloudProviderGlobal>;
    serviceOverrides?: pulumi.Input<pulumi.Input<inputs.ClusterRkeConfigCloudProviderAwsCloudProviderServiceOverride>[]>;
}

export interface ClusterRkeConfigCloudProviderAwsCloudProviderGlobal {
    disableSecurityGroupIngress?: pulumi.Input<boolean>;
    disableStrictZoneCheck?: pulumi.Input<boolean>;
    elbSecurityGroup?: pulumi.Input<string>;
    kubernetesClusterId?: pulumi.Input<string>;
    kubernetesClusterTag?: pulumi.Input<string>;
    roleArn?: pulumi.Input<string>;
    routeTableId?: pulumi.Input<string>;
    subnetId?: pulumi.Input<string>;
    vpc?: pulumi.Input<string>;
    zone?: pulumi.Input<string>;
}

export interface ClusterRkeConfigCloudProviderAwsCloudProviderServiceOverride {
    region?: pulumi.Input<string>;
    service: pulumi.Input<string>;
    signingMethod?: pulumi.Input<string>;
    signingName?: pulumi.Input<string>;
    signingRegion?: pulumi.Input<string>;
    url?: pulumi.Input<string>;
}

export interface ClusterRkeConfigCloudProviderAzureCloudProvider {
    aadClientCertPassword?: pulumi.Input<string>;
    aadClientCertPath?: pulumi.Input<string>;
    aadClientId: pulumi.Input<string>;
    aadClientSecret: pulumi.Input<string>;
    cloud?: pulumi.Input<string>;
    cloudProviderBackoff?: pulumi.Input<boolean>;
    cloudProviderBackoffDuration?: pulumi.Input<number>;
    cloudProviderBackoffExponent?: pulumi.Input<number>;
    cloudProviderBackoffJitter?: pulumi.Input<number>;
    cloudProviderBackoffRetries?: pulumi.Input<number>;
    cloudProviderRateLimit?: pulumi.Input<boolean>;
    cloudProviderRateLimitBucket?: pulumi.Input<number>;
    cloudProviderRateLimitQps?: pulumi.Input<number>;
    loadBalancerSku?: pulumi.Input<string>;
    location?: pulumi.Input<string>;
    maximumLoadBalancerRuleCount?: pulumi.Input<number>;
    primaryAvailabilitySetName?: pulumi.Input<string>;
    primaryScaleSetName?: pulumi.Input<string>;
    resourceGroup?: pulumi.Input<string>;
    routeTableName?: pulumi.Input<string>;
    securityGroupName?: pulumi.Input<string>;
    subnetName?: pulumi.Input<string>;
    subscriptionId: pulumi.Input<string>;
    tenantId: pulumi.Input<string>;
    useInstanceMetadata?: pulumi.Input<boolean>;
    useManagedIdentityExtension?: pulumi.Input<boolean>;
    vmType?: pulumi.Input<string>;
    vnetName?: pulumi.Input<string>;
    vnetResourceGroup?: pulumi.Input<string>;
}

export interface ClusterRkeConfigCloudProviderOpenstackCloudProvider {
    blockStorage?: pulumi.Input<inputs.ClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorage>;
    global: pulumi.Input<inputs.ClusterRkeConfigCloudProviderOpenstackCloudProviderGlobal>;
    loadBalancer?: pulumi.Input<inputs.ClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer>;
    metadata?: pulumi.Input<inputs.ClusterRkeConfigCloudProviderOpenstackCloudProviderMetadata>;
    route?: pulumi.Input<inputs.ClusterRkeConfigCloudProviderOpenstackCloudProviderRoute>;
}

export interface ClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorage {
    bsVersion?: pulumi.Input<string>;
    ignoreVolumeAz?: pulumi.Input<boolean>;
    trustDevicePath?: pulumi.Input<boolean>;
}

export interface ClusterRkeConfigCloudProviderOpenstackCloudProviderGlobal {
    authUrl: pulumi.Input<string>;
    caFile?: pulumi.Input<string>;
    domainId?: pulumi.Input<string>;
    domainName?: pulumi.Input<string>;
    password: pulumi.Input<string>;
    region?: pulumi.Input<string>;
    tenantId?: pulumi.Input<string>;
    tenantName?: pulumi.Input<string>;
    trustId?: pulumi.Input<string>;
    username: pulumi.Input<string>;
}

export interface ClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer {
    createMonitor?: pulumi.Input<boolean>;
    floatingNetworkId?: pulumi.Input<string>;
    lbMethod?: pulumi.Input<string>;
    lbProvider?: pulumi.Input<string>;
    lbVersion?: pulumi.Input<string>;
    manageSecurityGroups?: pulumi.Input<boolean>;
    monitorDelay?: pulumi.Input<string>;
    monitorMaxRetries?: pulumi.Input<number>;
    monitorTimeout?: pulumi.Input<string>;
    subnetId?: pulumi.Input<string>;
    useOctavia?: pulumi.Input<boolean>;
}

export interface ClusterRkeConfigCloudProviderOpenstackCloudProviderMetadata {
    requestTimeout?: pulumi.Input<number>;
    searchOrder?: pulumi.Input<string>;
}

export interface ClusterRkeConfigCloudProviderOpenstackCloudProviderRoute {
    routerId?: pulumi.Input<string>;
}

export interface ClusterRkeConfigCloudProviderVsphereCloudProvider {
    disk?: pulumi.Input<inputs.ClusterRkeConfigCloudProviderVsphereCloudProviderDisk>;
    global?: pulumi.Input<inputs.ClusterRkeConfigCloudProviderVsphereCloudProviderGlobal>;
    network?: pulumi.Input<inputs.ClusterRkeConfigCloudProviderVsphereCloudProviderNetwork>;
    virtualCenters: pulumi.Input<pulumi.Input<inputs.ClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenter>[]>;
    workspace: pulumi.Input<inputs.ClusterRkeConfigCloudProviderVsphereCloudProviderWorkspace>;
}

export interface ClusterRkeConfigCloudProviderVsphereCloudProviderDisk {
    scsiControllerType?: pulumi.Input<string>;
}

export interface ClusterRkeConfigCloudProviderVsphereCloudProviderGlobal {
    datacenters?: pulumi.Input<string>;
    insecureFlag?: pulumi.Input<boolean>;
    password?: pulumi.Input<string>;
    port?: pulumi.Input<string>;
    soapRoundtripCount?: pulumi.Input<number>;
    user?: pulumi.Input<string>;
}

export interface ClusterRkeConfigCloudProviderVsphereCloudProviderNetwork {
    publicNetwork?: pulumi.Input<string>;
}

export interface ClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenter {
    datacenters: pulumi.Input<string>;
    name: pulumi.Input<string>;
    password: pulumi.Input<string>;
    port?: pulumi.Input<string>;
    soapRoundtripCount?: pulumi.Input<number>;
    user: pulumi.Input<string>;
}

export interface ClusterRkeConfigCloudProviderVsphereCloudProviderWorkspace {
    datacenter: pulumi.Input<string>;
    defaultDatastore?: pulumi.Input<string>;
    folder: pulumi.Input<string>;
    resourcepoolPath?: pulumi.Input<string>;
    server: pulumi.Input<string>;
}

export interface ClusterRkeConfigDns {
    nodeSelector?: pulumi.Input<{[key: string]: any}>;
    nodelocal?: pulumi.Input<inputs.ClusterRkeConfigDnsNodelocal>;
    provider?: pulumi.Input<string>;
    reverseCidrs?: pulumi.Input<pulumi.Input<string>[]>;
    upstreamNameservers?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ClusterRkeConfigDnsNodelocal {
    ipAddress?: pulumi.Input<string>;
    nodeSelector?: pulumi.Input<{[key: string]: any}>;
}

export interface ClusterRkeConfigIngress {
    dnsPolicy?: pulumi.Input<string>;
    extraArgs?: pulumi.Input<{[key: string]: any}>;
    nodeSelector?: pulumi.Input<{[key: string]: any}>;
    options?: pulumi.Input<{[key: string]: any}>;
    provider?: pulumi.Input<string>;
}

export interface ClusterRkeConfigMonitoring {
    nodeSelector?: pulumi.Input<{[key: string]: any}>;
    options?: pulumi.Input<{[key: string]: any}>;
    provider?: pulumi.Input<string>;
    replicas?: pulumi.Input<number>;
    updateStrategy?: pulumi.Input<inputs.ClusterRkeConfigMonitoringUpdateStrategy>;
}

export interface ClusterRkeConfigMonitoringUpdateStrategy {
    rollingUpdate?: pulumi.Input<inputs.ClusterRkeConfigMonitoringUpdateStrategyRollingUpdate>;
    strategy?: pulumi.Input<string>;
}

export interface ClusterRkeConfigMonitoringUpdateStrategyRollingUpdate {
    maxSurge?: pulumi.Input<number>;
    maxUnavailable?: pulumi.Input<number>;
}

export interface ClusterRkeConfigNetwork {
    calicoNetworkProvider?: pulumi.Input<inputs.ClusterRkeConfigNetworkCalicoNetworkProvider>;
    canalNetworkProvider?: pulumi.Input<inputs.ClusterRkeConfigNetworkCanalNetworkProvider>;
    flannelNetworkProvider?: pulumi.Input<inputs.ClusterRkeConfigNetworkFlannelNetworkProvider>;
    mtu?: pulumi.Input<number>;
    options?: pulumi.Input<{[key: string]: any}>;
    plugin?: pulumi.Input<string>;
    weaveNetworkProvider?: pulumi.Input<inputs.ClusterRkeConfigNetworkWeaveNetworkProvider>;
}

export interface ClusterRkeConfigNetworkCalicoNetworkProvider {
    cloudProvider?: pulumi.Input<string>;
}

export interface ClusterRkeConfigNetworkCanalNetworkProvider {
    iface?: pulumi.Input<string>;
}

export interface ClusterRkeConfigNetworkFlannelNetworkProvider {
    iface?: pulumi.Input<string>;
}

export interface ClusterRkeConfigNetworkWeaveNetworkProvider {
    password: pulumi.Input<string>;
}

export interface ClusterRkeConfigNode {
    address: pulumi.Input<string>;
    dockerSocket?: pulumi.Input<string>;
    hostnameOverride?: pulumi.Input<string>;
    internalAddress?: pulumi.Input<string>;
    labels?: pulumi.Input<{[key: string]: any}>;
    nodeId?: pulumi.Input<string>;
    port?: pulumi.Input<string>;
    roles: pulumi.Input<pulumi.Input<string>[]>;
    sshAgentAuth?: pulumi.Input<boolean>;
    sshKey?: pulumi.Input<string>;
    sshKeyPath?: pulumi.Input<string>;
    user: pulumi.Input<string>;
}

export interface ClusterRkeConfigPrivateRegistry {
    isDefault?: pulumi.Input<boolean>;
    password?: pulumi.Input<string>;
    url: pulumi.Input<string>;
    user?: pulumi.Input<string>;
}

export interface ClusterRkeConfigServices {
    etcd?: pulumi.Input<inputs.ClusterRkeConfigServicesEtcd>;
    kubeApi?: pulumi.Input<inputs.ClusterRkeConfigServicesKubeApi>;
    kubeController?: pulumi.Input<inputs.ClusterRkeConfigServicesKubeController>;
    kubelet?: pulumi.Input<inputs.ClusterRkeConfigServicesKubelet>;
    kubeproxy?: pulumi.Input<inputs.ClusterRkeConfigServicesKubeproxy>;
    scheduler?: pulumi.Input<inputs.ClusterRkeConfigServicesScheduler>;
}

export interface ClusterRkeConfigServicesEtcd {
    backupConfig?: pulumi.Input<inputs.ClusterRkeConfigServicesEtcdBackupConfig>;
    caCert?: pulumi.Input<string>;
    cert?: pulumi.Input<string>;
    creation?: pulumi.Input<string>;
    externalUrls?: pulumi.Input<pulumi.Input<string>[]>;
    extraArgs?: pulumi.Input<{[key: string]: any}>;
    extraBinds?: pulumi.Input<pulumi.Input<string>[]>;
    extraEnvs?: pulumi.Input<pulumi.Input<string>[]>;
    gid?: pulumi.Input<number>;
    image?: pulumi.Input<string>;
    key?: pulumi.Input<string>;
    path?: pulumi.Input<string>;
    retention?: pulumi.Input<string>;
    snapshot?: pulumi.Input<boolean>;
    uid?: pulumi.Input<number>;
}

export interface ClusterRkeConfigServicesEtcdBackupConfig {
    enabled?: pulumi.Input<boolean>;
    intervalHours?: pulumi.Input<number>;
    retention?: pulumi.Input<number>;
    s3BackupConfig?: pulumi.Input<inputs.ClusterRkeConfigServicesEtcdBackupConfigS3BackupConfig>;
    safeTimestamp?: pulumi.Input<boolean>;
}

export interface ClusterRkeConfigServicesEtcdBackupConfigS3BackupConfig {
    accessKey?: pulumi.Input<string>;
    bucketName: pulumi.Input<string>;
    customCa?: pulumi.Input<string>;
    endpoint: pulumi.Input<string>;
    folder?: pulumi.Input<string>;
    region?: pulumi.Input<string>;
    secretKey?: pulumi.Input<string>;
}

export interface ClusterRkeConfigServicesKubeApi {
    admissionConfiguration?: pulumi.Input<{[key: string]: any}>;
    alwaysPullImages?: pulumi.Input<boolean>;
    auditLog?: pulumi.Input<inputs.ClusterRkeConfigServicesKubeApiAuditLog>;
    eventRateLimit?: pulumi.Input<inputs.ClusterRkeConfigServicesKubeApiEventRateLimit>;
    extraArgs?: pulumi.Input<{[key: string]: any}>;
    extraBinds?: pulumi.Input<pulumi.Input<string>[]>;
    extraEnvs?: pulumi.Input<pulumi.Input<string>[]>;
    image?: pulumi.Input<string>;
    podSecurityPolicy?: pulumi.Input<boolean>;
    secretsEncryptionConfig?: pulumi.Input<inputs.ClusterRkeConfigServicesKubeApiSecretsEncryptionConfig>;
    serviceClusterIpRange?: pulumi.Input<string>;
    serviceNodePortRange?: pulumi.Input<string>;
}

export interface ClusterRkeConfigServicesKubeApiAuditLog {
    configuration?: pulumi.Input<inputs.ClusterRkeConfigServicesKubeApiAuditLogConfiguration>;
    enabled?: pulumi.Input<boolean>;
}

export interface ClusterRkeConfigServicesKubeApiAuditLogConfiguration {
    format?: pulumi.Input<string>;
    maxAge?: pulumi.Input<number>;
    maxBackup?: pulumi.Input<number>;
    maxSize?: pulumi.Input<number>;
    path?: pulumi.Input<string>;
    policy?: pulumi.Input<string>;
}

export interface ClusterRkeConfigServicesKubeApiEventRateLimit {
    configuration?: pulumi.Input<string>;
    enabled?: pulumi.Input<boolean>;
}

export interface ClusterRkeConfigServicesKubeApiSecretsEncryptionConfig {
    customConfig?: pulumi.Input<string>;
    enabled?: pulumi.Input<boolean>;
}

export interface ClusterRkeConfigServicesKubeController {
    clusterCidr?: pulumi.Input<string>;
    extraArgs?: pulumi.Input<{[key: string]: any}>;
    extraBinds?: pulumi.Input<pulumi.Input<string>[]>;
    extraEnvs?: pulumi.Input<pulumi.Input<string>[]>;
    image?: pulumi.Input<string>;
    serviceClusterIpRange?: pulumi.Input<string>;
}

export interface ClusterRkeConfigServicesKubelet {
    clusterDnsServer?: pulumi.Input<string>;
    clusterDomain?: pulumi.Input<string>;
    extraArgs?: pulumi.Input<{[key: string]: any}>;
    extraBinds?: pulumi.Input<pulumi.Input<string>[]>;
    extraEnvs?: pulumi.Input<pulumi.Input<string>[]>;
    failSwapOn?: pulumi.Input<boolean>;
    generateServingCertificate?: pulumi.Input<boolean>;
    image?: pulumi.Input<string>;
    infraContainerImage?: pulumi.Input<string>;
}

export interface ClusterRkeConfigServicesKubeproxy {
    extraArgs?: pulumi.Input<{[key: string]: any}>;
    extraBinds?: pulumi.Input<pulumi.Input<string>[]>;
    extraEnvs?: pulumi.Input<pulumi.Input<string>[]>;
    image?: pulumi.Input<string>;
}

export interface ClusterRkeConfigServicesScheduler {
    extraArgs?: pulumi.Input<{[key: string]: any}>;
    extraBinds?: pulumi.Input<pulumi.Input<string>[]>;
    extraEnvs?: pulumi.Input<pulumi.Input<string>[]>;
    image?: pulumi.Input<string>;
}

export interface ClusterRkeConfigUpgradeStrategy {
    drain?: pulumi.Input<boolean>;
    drainInput?: pulumi.Input<inputs.ClusterRkeConfigUpgradeStrategyDrainInput>;
    maxUnavailableControlplane?: pulumi.Input<string>;
    maxUnavailableWorker?: pulumi.Input<string>;
}

export interface ClusterRkeConfigUpgradeStrategyDrainInput {
    deleteLocalData?: pulumi.Input<boolean>;
    force?: pulumi.Input<boolean>;
    gracePeriod?: pulumi.Input<number>;
    ignoreDaemonSets?: pulumi.Input<boolean>;
    timeout?: pulumi.Input<number>;
}

export interface ClusterScheduledClusterScan {
    enabled?: pulumi.Input<boolean>;
    scanConfig: pulumi.Input<inputs.ClusterScheduledClusterScanScanConfig>;
    scheduleConfig: pulumi.Input<inputs.ClusterScheduledClusterScanScheduleConfig>;
}

export interface ClusterScheduledClusterScanScanConfig {
    cisScanConfig?: pulumi.Input<inputs.ClusterScheduledClusterScanScanConfigCisScanConfig>;
}

export interface ClusterScheduledClusterScanScanConfigCisScanConfig {
    debugMaster?: pulumi.Input<boolean>;
    debugWorker?: pulumi.Input<boolean>;
    overrideBenchmarkVersion?: pulumi.Input<string>;
    overrideSkips?: pulumi.Input<pulumi.Input<string>[]>;
    profile?: pulumi.Input<string>;
}

export interface ClusterScheduledClusterScanScheduleConfig {
    cronSchedule: pulumi.Input<string>;
    retention?: pulumi.Input<number>;
}

export interface ClusterTemplateMember {
    accessType?: pulumi.Input<string>;
    groupPrincipalId?: pulumi.Input<string>;
    userPrincipalId?: pulumi.Input<string>;
}

export interface ClusterTemplateTemplateRevision {
    annotations?: pulumi.Input<{[key: string]: any}>;
    clusterConfig: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfig>;
    clusterTemplateId?: pulumi.Input<string>;
    default?: pulumi.Input<boolean>;
    enabled?: pulumi.Input<boolean>;
    id?: pulumi.Input<string>;
    labels?: pulumi.Input<{[key: string]: any}>;
    name: pulumi.Input<string>;
    questions?: pulumi.Input<pulumi.Input<inputs.ClusterTemplateTemplateRevisionQuestion>[]>;
}

export interface ClusterTemplateTemplateRevisionClusterConfig {
    clusterAuthEndpoint?: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigClusterAuthEndpoint>;
    defaultClusterRoleForProjectMembers?: pulumi.Input<string>;
    defaultPodSecurityPolicyTemplateId?: pulumi.Input<string>;
    desiredAgentImage?: pulumi.Input<string>;
    desiredAuthImage?: pulumi.Input<string>;
    dockerRootDir?: pulumi.Input<string>;
    enableClusterAlerting?: pulumi.Input<boolean>;
    enableClusterMonitoring?: pulumi.Input<boolean>;
    enableNetworkPolicy?: pulumi.Input<boolean>;
    rkeConfig: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfig>;
    scheduledClusterScan?: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigScheduledClusterScan>;
    windowsPreferedCluster?: pulumi.Input<boolean>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigClusterAuthEndpoint {
    caCerts?: pulumi.Input<string>;
    enabled?: pulumi.Input<boolean>;
    fqdn?: pulumi.Input<string>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfig {
    addonJobTimeout?: pulumi.Input<number>;
    addons?: pulumi.Input<string>;
    addonsIncludes?: pulumi.Input<pulumi.Input<string>[]>;
    authentication?: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthentication>;
    authorization?: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthorization>;
    bastionHost?: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigBastionHost>;
    cloudProvider?: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProvider>;
    dns?: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigDns>;
    ignoreDockerVersion?: pulumi.Input<boolean>;
    ingress?: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngress>;
    kubernetesVersion?: pulumi.Input<string>;
    monitoring?: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoring>;
    network?: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetwork>;
    nodes?: pulumi.Input<pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigNode>[]>;
    prefixPath?: pulumi.Input<string>;
    privateRegistries?: pulumi.Input<pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistry>[]>;
    services?: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServices>;
    sshAgentAuth?: pulumi.Input<boolean>;
    sshCertPath?: pulumi.Input<string>;
    sshKeyPath?: pulumi.Input<string>;
    upgradeStrategy?: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategy>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthentication {
    sans?: pulumi.Input<pulumi.Input<string>[]>;
    strategy?: pulumi.Input<string>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthorization {
    mode?: pulumi.Input<string>;
    options?: pulumi.Input<{[key: string]: any}>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigBastionHost {
    address: pulumi.Input<string>;
    port?: pulumi.Input<string>;
    sshAgentAuth?: pulumi.Input<boolean>;
    sshKey?: pulumi.Input<string>;
    sshKeyPath?: pulumi.Input<string>;
    user: pulumi.Input<string>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProvider {
    awsCloudProvider?: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProvider>;
    azureCloudProvider?: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAzureCloudProvider>;
    customCloudProvider?: pulumi.Input<string>;
    name?: pulumi.Input<string>;
    openstackCloudProvider?: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProvider>;
    vsphereCloudProvider?: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProvider>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProvider {
    global?: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderGlobal>;
    serviceOverrides?: pulumi.Input<pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderServiceOverride>[]>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderGlobal {
    disableSecurityGroupIngress?: pulumi.Input<boolean>;
    disableStrictZoneCheck?: pulumi.Input<boolean>;
    elbSecurityGroup?: pulumi.Input<string>;
    kubernetesClusterId?: pulumi.Input<string>;
    kubernetesClusterTag?: pulumi.Input<string>;
    roleArn?: pulumi.Input<string>;
    routeTableId?: pulumi.Input<string>;
    subnetId?: pulumi.Input<string>;
    vpc?: pulumi.Input<string>;
    zone?: pulumi.Input<string>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderServiceOverride {
    region?: pulumi.Input<string>;
    service: pulumi.Input<string>;
    signingMethod?: pulumi.Input<string>;
    signingName?: pulumi.Input<string>;
    signingRegion?: pulumi.Input<string>;
    url?: pulumi.Input<string>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAzureCloudProvider {
    aadClientCertPassword?: pulumi.Input<string>;
    aadClientCertPath?: pulumi.Input<string>;
    aadClientId: pulumi.Input<string>;
    aadClientSecret: pulumi.Input<string>;
    cloud?: pulumi.Input<string>;
    cloudProviderBackoff?: pulumi.Input<boolean>;
    cloudProviderBackoffDuration?: pulumi.Input<number>;
    cloudProviderBackoffExponent?: pulumi.Input<number>;
    cloudProviderBackoffJitter?: pulumi.Input<number>;
    cloudProviderBackoffRetries?: pulumi.Input<number>;
    cloudProviderRateLimit?: pulumi.Input<boolean>;
    cloudProviderRateLimitBucket?: pulumi.Input<number>;
    cloudProviderRateLimitQps?: pulumi.Input<number>;
    loadBalancerSku?: pulumi.Input<string>;
    location?: pulumi.Input<string>;
    maximumLoadBalancerRuleCount?: pulumi.Input<number>;
    primaryAvailabilitySetName?: pulumi.Input<string>;
    primaryScaleSetName?: pulumi.Input<string>;
    resourceGroup?: pulumi.Input<string>;
    routeTableName?: pulumi.Input<string>;
    securityGroupName?: pulumi.Input<string>;
    subnetName?: pulumi.Input<string>;
    subscriptionId: pulumi.Input<string>;
    tenantId: pulumi.Input<string>;
    useInstanceMetadata?: pulumi.Input<boolean>;
    useManagedIdentityExtension?: pulumi.Input<boolean>;
    vmType?: pulumi.Input<string>;
    vnetName?: pulumi.Input<string>;
    vnetResourceGroup?: pulumi.Input<string>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProvider {
    blockStorage?: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderBlockStorage>;
    global: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderGlobal>;
    loadBalancer?: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer>;
    metadata?: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderMetadata>;
    route?: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderRoute>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderBlockStorage {
    bsVersion?: pulumi.Input<string>;
    ignoreVolumeAz?: pulumi.Input<boolean>;
    trustDevicePath?: pulumi.Input<boolean>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderGlobal {
    authUrl: pulumi.Input<string>;
    caFile?: pulumi.Input<string>;
    domainId?: pulumi.Input<string>;
    domainName?: pulumi.Input<string>;
    password: pulumi.Input<string>;
    region?: pulumi.Input<string>;
    tenantId?: pulumi.Input<string>;
    tenantName?: pulumi.Input<string>;
    trustId?: pulumi.Input<string>;
    username: pulumi.Input<string>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer {
    createMonitor?: pulumi.Input<boolean>;
    floatingNetworkId?: pulumi.Input<string>;
    lbMethod?: pulumi.Input<string>;
    lbProvider?: pulumi.Input<string>;
    lbVersion?: pulumi.Input<string>;
    manageSecurityGroups?: pulumi.Input<boolean>;
    monitorDelay?: pulumi.Input<string>;
    monitorMaxRetries?: pulumi.Input<number>;
    monitorTimeout?: pulumi.Input<string>;
    subnetId?: pulumi.Input<string>;
    useOctavia?: pulumi.Input<boolean>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderMetadata {
    requestTimeout?: pulumi.Input<number>;
    searchOrder?: pulumi.Input<string>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderRoute {
    routerId?: pulumi.Input<string>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProvider {
    disk?: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderDisk>;
    global?: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderGlobal>;
    network?: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderNetwork>;
    virtualCenters: pulumi.Input<pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderVirtualCenter>[]>;
    workspace: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderWorkspace>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderDisk {
    scsiControllerType?: pulumi.Input<string>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderGlobal {
    datacenters?: pulumi.Input<string>;
    insecureFlag?: pulumi.Input<boolean>;
    password?: pulumi.Input<string>;
    port?: pulumi.Input<string>;
    soapRoundtripCount?: pulumi.Input<number>;
    user?: pulumi.Input<string>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderNetwork {
    publicNetwork?: pulumi.Input<string>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderVirtualCenter {
    datacenters: pulumi.Input<string>;
    name: pulumi.Input<string>;
    password: pulumi.Input<string>;
    port?: pulumi.Input<string>;
    soapRoundtripCount?: pulumi.Input<number>;
    user: pulumi.Input<string>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderWorkspace {
    datacenter: pulumi.Input<string>;
    defaultDatastore?: pulumi.Input<string>;
    folder: pulumi.Input<string>;
    resourcepoolPath?: pulumi.Input<string>;
    server: pulumi.Input<string>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigDns {
    nodeSelector?: pulumi.Input<{[key: string]: any}>;
    nodelocal?: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsNodelocal>;
    provider?: pulumi.Input<string>;
    reverseCidrs?: pulumi.Input<pulumi.Input<string>[]>;
    upstreamNameservers?: pulumi.Input<pulumi.Input<string>[]>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsNodelocal {
    ipAddress?: pulumi.Input<string>;
    nodeSelector?: pulumi.Input<{[key: string]: any}>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngress {
    dnsPolicy?: pulumi.Input<string>;
    extraArgs?: pulumi.Input<{[key: string]: any}>;
    nodeSelector?: pulumi.Input<{[key: string]: any}>;
    options?: pulumi.Input<{[key: string]: any}>;
    provider?: pulumi.Input<string>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoring {
    nodeSelector?: pulumi.Input<{[key: string]: any}>;
    options?: pulumi.Input<{[key: string]: any}>;
    provider?: pulumi.Input<string>;
    replicas?: pulumi.Input<number>;
    updateStrategy?: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategy>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategy {
    rollingUpdate?: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyRollingUpdate>;
    strategy?: pulumi.Input<string>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyRollingUpdate {
    maxSurge?: pulumi.Input<number>;
    maxUnavailable?: pulumi.Input<number>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetwork {
    calicoNetworkProvider?: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCalicoNetworkProvider>;
    canalNetworkProvider?: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCanalNetworkProvider>;
    flannelNetworkProvider?: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkFlannelNetworkProvider>;
    mtu?: pulumi.Input<number>;
    options?: pulumi.Input<{[key: string]: any}>;
    plugin?: pulumi.Input<string>;
    weaveNetworkProvider?: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkWeaveNetworkProvider>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCalicoNetworkProvider {
    cloudProvider?: pulumi.Input<string>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCanalNetworkProvider {
    iface?: pulumi.Input<string>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkFlannelNetworkProvider {
    iface?: pulumi.Input<string>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkWeaveNetworkProvider {
    password: pulumi.Input<string>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigNode {
    address: pulumi.Input<string>;
    dockerSocket?: pulumi.Input<string>;
    hostnameOverride?: pulumi.Input<string>;
    internalAddress?: pulumi.Input<string>;
    labels?: pulumi.Input<{[key: string]: any}>;
    nodeId?: pulumi.Input<string>;
    port?: pulumi.Input<string>;
    roles: pulumi.Input<pulumi.Input<string>[]>;
    sshAgentAuth?: pulumi.Input<boolean>;
    sshKey?: pulumi.Input<string>;
    sshKeyPath?: pulumi.Input<string>;
    user: pulumi.Input<string>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistry {
    isDefault?: pulumi.Input<boolean>;
    password?: pulumi.Input<string>;
    url: pulumi.Input<string>;
    user?: pulumi.Input<string>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServices {
    etcd?: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcd>;
    kubeApi?: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApi>;
    kubeController?: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeController>;
    kubelet?: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubelet>;
    kubeproxy?: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeproxy>;
    scheduler?: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesScheduler>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcd {
    backupConfig?: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfig>;
    caCert?: pulumi.Input<string>;
    cert?: pulumi.Input<string>;
    creation?: pulumi.Input<string>;
    externalUrls?: pulumi.Input<pulumi.Input<string>[]>;
    extraArgs?: pulumi.Input<{[key: string]: any}>;
    extraBinds?: pulumi.Input<pulumi.Input<string>[]>;
    extraEnvs?: pulumi.Input<pulumi.Input<string>[]>;
    gid?: pulumi.Input<number>;
    image?: pulumi.Input<string>;
    key?: pulumi.Input<string>;
    path?: pulumi.Input<string>;
    retention?: pulumi.Input<string>;
    snapshot?: pulumi.Input<boolean>;
    uid?: pulumi.Input<number>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfig {
    enabled?: pulumi.Input<boolean>;
    intervalHours?: pulumi.Input<number>;
    retention?: pulumi.Input<number>;
    s3BackupConfig?: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfigS3BackupConfig>;
    safeTimestamp?: pulumi.Input<boolean>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfigS3BackupConfig {
    accessKey?: pulumi.Input<string>;
    bucketName: pulumi.Input<string>;
    customCa?: pulumi.Input<string>;
    endpoint: pulumi.Input<string>;
    folder?: pulumi.Input<string>;
    region?: pulumi.Input<string>;
    secretKey?: pulumi.Input<string>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApi {
    admissionConfiguration?: pulumi.Input<{[key: string]: any}>;
    alwaysPullImages?: pulumi.Input<boolean>;
    auditLog?: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLog>;
    eventRateLimit?: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiEventRateLimit>;
    extraArgs?: pulumi.Input<{[key: string]: any}>;
    extraBinds?: pulumi.Input<pulumi.Input<string>[]>;
    extraEnvs?: pulumi.Input<pulumi.Input<string>[]>;
    image?: pulumi.Input<string>;
    podSecurityPolicy?: pulumi.Input<boolean>;
    secretsEncryptionConfig?: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiSecretsEncryptionConfig>;
    serviceClusterIpRange?: pulumi.Input<string>;
    serviceNodePortRange?: pulumi.Input<string>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLog {
    configuration?: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLogConfiguration>;
    enabled?: pulumi.Input<boolean>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLogConfiguration {
    format?: pulumi.Input<string>;
    maxAge?: pulumi.Input<number>;
    maxBackup?: pulumi.Input<number>;
    maxSize?: pulumi.Input<number>;
    path?: pulumi.Input<string>;
    policy?: pulumi.Input<string>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiEventRateLimit {
    configuration?: pulumi.Input<string>;
    enabled?: pulumi.Input<boolean>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiSecretsEncryptionConfig {
    customConfig?: pulumi.Input<string>;
    enabled?: pulumi.Input<boolean>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeController {
    clusterCidr?: pulumi.Input<string>;
    extraArgs?: pulumi.Input<{[key: string]: any}>;
    extraBinds?: pulumi.Input<pulumi.Input<string>[]>;
    extraEnvs?: pulumi.Input<pulumi.Input<string>[]>;
    image?: pulumi.Input<string>;
    serviceClusterIpRange?: pulumi.Input<string>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubelet {
    clusterDnsServer?: pulumi.Input<string>;
    clusterDomain?: pulumi.Input<string>;
    extraArgs?: pulumi.Input<{[key: string]: any}>;
    extraBinds?: pulumi.Input<pulumi.Input<string>[]>;
    extraEnvs?: pulumi.Input<pulumi.Input<string>[]>;
    failSwapOn?: pulumi.Input<boolean>;
    generateServingCertificate?: pulumi.Input<boolean>;
    image?: pulumi.Input<string>;
    infraContainerImage?: pulumi.Input<string>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeproxy {
    extraArgs?: pulumi.Input<{[key: string]: any}>;
    extraBinds?: pulumi.Input<pulumi.Input<string>[]>;
    extraEnvs?: pulumi.Input<pulumi.Input<string>[]>;
    image?: pulumi.Input<string>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesScheduler {
    extraArgs?: pulumi.Input<{[key: string]: any}>;
    extraBinds?: pulumi.Input<pulumi.Input<string>[]>;
    extraEnvs?: pulumi.Input<pulumi.Input<string>[]>;
    image?: pulumi.Input<string>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategy {
    drain?: pulumi.Input<boolean>;
    drainInput?: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyDrainInput>;
    maxUnavailableControlplane?: pulumi.Input<string>;
    maxUnavailableWorker?: pulumi.Input<string>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyDrainInput {
    deleteLocalData?: pulumi.Input<boolean>;
    force?: pulumi.Input<boolean>;
    gracePeriod?: pulumi.Input<number>;
    ignoreDaemonSets?: pulumi.Input<boolean>;
    timeout?: pulumi.Input<number>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigScheduledClusterScan {
    enabled?: pulumi.Input<boolean>;
    scanConfig: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigScheduledClusterScanScanConfig>;
    scheduleConfig: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigScheduledClusterScanScheduleConfig>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigScheduledClusterScanScanConfig {
    cisScanConfig?: pulumi.Input<inputs.ClusterTemplateTemplateRevisionClusterConfigScheduledClusterScanScanConfigCisScanConfig>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigScheduledClusterScanScanConfigCisScanConfig {
    debugMaster?: pulumi.Input<boolean>;
    debugWorker?: pulumi.Input<boolean>;
    overrideBenchmarkVersion?: pulumi.Input<string>;
    overrideSkips?: pulumi.Input<pulumi.Input<string>[]>;
    profile?: pulumi.Input<string>;
}

export interface ClusterTemplateTemplateRevisionClusterConfigScheduledClusterScanScheduleConfig {
    cronSchedule: pulumi.Input<string>;
    retention?: pulumi.Input<number>;
}

export interface ClusterTemplateTemplateRevisionQuestion {
    default: pulumi.Input<string>;
    required?: pulumi.Input<boolean>;
    type?: pulumi.Input<string>;
    variable: pulumi.Input<string>;
}

export interface EtcdBackupBackupConfig {
    enabled?: pulumi.Input<boolean>;
    intervalHours?: pulumi.Input<number>;
    retention?: pulumi.Input<number>;
    s3BackupConfig?: pulumi.Input<inputs.EtcdBackupBackupConfigS3BackupConfig>;
    safeTimestamp?: pulumi.Input<boolean>;
}

export interface EtcdBackupBackupConfigS3BackupConfig {
    accessKey?: pulumi.Input<string>;
    bucketName: pulumi.Input<string>;
    customCa?: pulumi.Input<string>;
    endpoint: pulumi.Input<string>;
    folder?: pulumi.Input<string>;
    region?: pulumi.Input<string>;
    secretKey?: pulumi.Input<string>;
}

export interface GetPodSecurityPolicyTemplateAllowedCsiDriver {
    name: string;
}

export interface GetPodSecurityPolicyTemplateAllowedFlexVolume {
    driver: string;
}

export interface GetPodSecurityPolicyTemplateAllowedHostPath {
    pathPrefix: string;
    readOnly?: boolean;
}

export interface GetPodSecurityPolicyTemplateFsGroup {
    ranges?: inputs.GetPodSecurityPolicyTemplateFsGroupRange[];
    rule?: string;
}

export interface GetPodSecurityPolicyTemplateFsGroupRange {
    max: number;
    min: number;
}

export interface GetPodSecurityPolicyTemplateHostPort {
    max: number;
    min: number;
}

export interface GetPodSecurityPolicyTemplateRunAsGroup {
    ranges?: inputs.GetPodSecurityPolicyTemplateRunAsGroupRange[];
    rule: string;
}

export interface GetPodSecurityPolicyTemplateRunAsGroupRange {
    max: number;
    min: number;
}

export interface GetPodSecurityPolicyTemplateRunAsUser {
    ranges?: inputs.GetPodSecurityPolicyTemplateRunAsUserRange[];
    rule: string;
}

export interface GetPodSecurityPolicyTemplateRunAsUserRange {
    max: number;
    min: number;
}

export interface GetPodSecurityPolicyTemplateRuntimeClass {
    allowedRuntimeClassNames: string[];
    defaultRuntimeClassName?: string;
}

export interface GetPodSecurityPolicyTemplateSeLinux {
    rule: string;
    seLinuxOption?: inputs.GetPodSecurityPolicyTemplateSeLinuxSeLinuxOption;
}

export interface GetPodSecurityPolicyTemplateSeLinuxSeLinuxOption {
    level?: string;
    role?: string;
    type?: string;
    user?: string;
}

export interface GetPodSecurityPolicyTemplateSupplementalGroup {
    ranges?: inputs.GetPodSecurityPolicyTemplateSupplementalGroupRange[];
    rule?: string;
}

export interface GetPodSecurityPolicyTemplateSupplementalGroupRange {
    max: number;
    min: number;
}

export interface MultiClusterAppAnswer {
    clusterId?: pulumi.Input<string>;
    projectId?: pulumi.Input<string>;
    values?: pulumi.Input<{[key: string]: any}>;
}

export interface MultiClusterAppMember {
    accessType?: pulumi.Input<string>;
    groupPrincipalId?: pulumi.Input<string>;
    userPrincipalId?: pulumi.Input<string>;
}

export interface MultiClusterAppTarget {
    appId?: pulumi.Input<string>;
    healthState?: pulumi.Input<string>;
    projectId: pulumi.Input<string>;
    state?: pulumi.Input<string>;
}

export interface MultiClusterAppUpgradeStrategy {
    rollingUpdate?: pulumi.Input<inputs.MultiClusterAppUpgradeStrategyRollingUpdate>;
}

export interface MultiClusterAppUpgradeStrategyRollingUpdate {
    batchSize?: pulumi.Input<number>;
    interval?: pulumi.Input<number>;
}

export interface NamespaceContainerResourceLimit {
    limitsCpu?: pulumi.Input<string>;
    limitsMemory?: pulumi.Input<string>;
    requestsCpu?: pulumi.Input<string>;
    requestsMemory?: pulumi.Input<string>;
}

export interface NamespaceResourceQuota {
    limit: pulumi.Input<inputs.NamespaceResourceQuotaLimit>;
}

export interface NamespaceResourceQuotaLimit {
    configMaps?: pulumi.Input<string>;
    limitsCpu?: pulumi.Input<string>;
    limitsMemory?: pulumi.Input<string>;
    persistentVolumeClaims?: pulumi.Input<string>;
    pods?: pulumi.Input<string>;
    replicationControllers?: pulumi.Input<string>;
    requestsCpu?: pulumi.Input<string>;
    requestsMemory?: pulumi.Input<string>;
    requestsStorage?: pulumi.Input<string>;
    secrets?: pulumi.Input<string>;
    services?: pulumi.Input<string>;
    servicesLoadBalancers?: pulumi.Input<string>;
    servicesNodePorts?: pulumi.Input<string>;
}

export interface NodePoolNodeTaint {
    effect?: pulumi.Input<string>;
    key: pulumi.Input<string>;
    timeAdded?: pulumi.Input<string>;
    value: pulumi.Input<string>;
}

export interface NodeTemplateAmazonec2Config {
    accessKey?: pulumi.Input<string>;
    ami: pulumi.Input<string>;
    blockDurationMinutes?: pulumi.Input<string>;
    deviceName?: pulumi.Input<string>;
    encryptEbsVolume?: pulumi.Input<boolean>;
    endpoint?: pulumi.Input<string>;
    iamInstanceProfile?: pulumi.Input<string>;
    insecureTransport?: pulumi.Input<boolean>;
    instanceType?: pulumi.Input<string>;
    keypairName?: pulumi.Input<string>;
    kmsKey?: pulumi.Input<string>;
    monitoring?: pulumi.Input<boolean>;
    openPorts?: pulumi.Input<pulumi.Input<string>[]>;
    privateAddressOnly?: pulumi.Input<boolean>;
    region: pulumi.Input<string>;
    requestSpotInstance?: pulumi.Input<boolean>;
    retries?: pulumi.Input<string>;
    rootSize?: pulumi.Input<string>;
    secretKey?: pulumi.Input<string>;
    securityGroupReadonly?: pulumi.Input<boolean>;
    securityGroups: pulumi.Input<pulumi.Input<string>[]>;
    sessionToken?: pulumi.Input<string>;
    spotPrice?: pulumi.Input<string>;
    sshKeypath?: pulumi.Input<string>;
    sshUser?: pulumi.Input<string>;
    subnetId: pulumi.Input<string>;
    tags?: pulumi.Input<string>;
    useEbsOptimizedInstance?: pulumi.Input<boolean>;
    usePrivateAddress?: pulumi.Input<boolean>;
    userdata?: pulumi.Input<string>;
    volumeType?: pulumi.Input<string>;
    vpcId: pulumi.Input<string>;
    zone: pulumi.Input<string>;
}

export interface NodeTemplateAzureConfig {
    availabilitySet?: pulumi.Input<string>;
    clientId?: pulumi.Input<string>;
    clientSecret?: pulumi.Input<string>;
    customData?: pulumi.Input<string>;
    diskSize?: pulumi.Input<string>;
    dns?: pulumi.Input<string>;
    dockerPort?: pulumi.Input<string>;
    environment?: pulumi.Input<string>;
    faultDomainCount?: pulumi.Input<string>;
    image?: pulumi.Input<string>;
    location?: pulumi.Input<string>;
    managedDisks?: pulumi.Input<boolean>;
    noPublicIp?: pulumi.Input<boolean>;
    nsg?: pulumi.Input<string>;
    openPorts?: pulumi.Input<pulumi.Input<string>[]>;
    privateIpAddress?: pulumi.Input<string>;
    resourceGroup?: pulumi.Input<string>;
    size?: pulumi.Input<string>;
    sshUser?: pulumi.Input<string>;
    staticPublicIp?: pulumi.Input<boolean>;
    storageType?: pulumi.Input<string>;
    subnet?: pulumi.Input<string>;
    subnetPrefix?: pulumi.Input<string>;
    subscriptionId?: pulumi.Input<string>;
    updateDomainCount?: pulumi.Input<string>;
    usePrivateIp?: pulumi.Input<boolean>;
    vnet?: pulumi.Input<string>;
}

export interface NodeTemplateDigitaloceanConfig {
    accessToken?: pulumi.Input<string>;
    backups?: pulumi.Input<boolean>;
    image?: pulumi.Input<string>;
    ipv6?: pulumi.Input<boolean>;
    monitoring?: pulumi.Input<boolean>;
    privateNetworking?: pulumi.Input<boolean>;
    region?: pulumi.Input<string>;
    size?: pulumi.Input<string>;
    sshKeyFingerprint?: pulumi.Input<string>;
    sshKeyPath?: pulumi.Input<string>;
    sshPort?: pulumi.Input<string>;
    sshUser?: pulumi.Input<string>;
    tags?: pulumi.Input<string>;
    userdata?: pulumi.Input<string>;
}

export interface NodeTemplateLinodeConfig {
    authorizedUsers?: pulumi.Input<string>;
    createPrivateIp?: pulumi.Input<boolean>;
    dockerPort?: pulumi.Input<string>;
    image?: pulumi.Input<string>;
    instanceType?: pulumi.Input<string>;
    label?: pulumi.Input<string>;
    region?: pulumi.Input<string>;
    rootPass?: pulumi.Input<string>;
    sshPort?: pulumi.Input<string>;
    sshUser?: pulumi.Input<string>;
    stackscript?: pulumi.Input<string>;
    stackscriptData?: pulumi.Input<string>;
    swapSize?: pulumi.Input<string>;
    tags?: pulumi.Input<string>;
    token?: pulumi.Input<string>;
    uaPrefix?: pulumi.Input<string>;
}

export interface NodeTemplateOpennebulaConfig {
    b2dSize?: pulumi.Input<string>;
    cpu?: pulumi.Input<string>;
    devPrefix?: pulumi.Input<string>;
    disableVnc?: pulumi.Input<boolean>;
    diskResize?: pulumi.Input<string>;
    imageId?: pulumi.Input<string>;
    imageName?: pulumi.Input<string>;
    imageOwner?: pulumi.Input<string>;
    memory?: pulumi.Input<string>;
    networkId?: pulumi.Input<string>;
    networkName?: pulumi.Input<string>;
    networkOwner?: pulumi.Input<string>;
    password: pulumi.Input<string>;
    sshUser?: pulumi.Input<string>;
    templateId?: pulumi.Input<string>;
    templateName?: pulumi.Input<string>;
    user: pulumi.Input<string>;
    vcpu?: pulumi.Input<string>;
    xmlRpcUrl: pulumi.Input<string>;
}

export interface NodeTemplateOpenstackConfig {
    activeTimeout?: pulumi.Input<string>;
    authUrl: pulumi.Input<string>;
    availabilityZone: pulumi.Input<string>;
    cacert?: pulumi.Input<string>;
    configDrive?: pulumi.Input<boolean>;
    domainId?: pulumi.Input<string>;
    domainName?: pulumi.Input<string>;
    endpointType?: pulumi.Input<string>;
    flavorId?: pulumi.Input<string>;
    flavorName?: pulumi.Input<string>;
    floatingIpPool?: pulumi.Input<string>;
    imageId?: pulumi.Input<string>;
    imageName?: pulumi.Input<string>;
    insecure?: pulumi.Input<boolean>;
    ipVersion?: pulumi.Input<string>;
    keypairName?: pulumi.Input<string>;
    netId?: pulumi.Input<string>;
    netName?: pulumi.Input<string>;
    novaNetwork?: pulumi.Input<boolean>;
    password?: pulumi.Input<string>;
    privateKeyFile?: pulumi.Input<string>;
    region: pulumi.Input<string>;
    secGroups?: pulumi.Input<string>;
    sshPort?: pulumi.Input<string>;
    sshUser?: pulumi.Input<string>;
    tenantId?: pulumi.Input<string>;
    tenantName?: pulumi.Input<string>;
    userDataFile?: pulumi.Input<string>;
    username: pulumi.Input<string>;
}

export interface NodeTemplateVsphereConfig {
    boot2dockerUrl?: pulumi.Input<string>;
    cfgparams?: pulumi.Input<pulumi.Input<string>[]>;
    cloneFrom?: pulumi.Input<string>;
    cloudConfig?: pulumi.Input<string>;
    cloudinit?: pulumi.Input<string>;
    contentLibrary?: pulumi.Input<string>;
    cpuCount?: pulumi.Input<string>;
    creationType?: pulumi.Input<string>;
    customAttributes?: pulumi.Input<pulumi.Input<string>[]>;
    datacenter?: pulumi.Input<string>;
    datastore?: pulumi.Input<string>;
    datastoreCluster?: pulumi.Input<string>;
    diskSize?: pulumi.Input<string>;
    folder?: pulumi.Input<string>;
    hostsystem?: pulumi.Input<string>;
    memorySize?: pulumi.Input<string>;
    networks?: pulumi.Input<pulumi.Input<string>[]>;
    password?: pulumi.Input<string>;
    pool?: pulumi.Input<string>;
    sshPassword?: pulumi.Input<string>;
    sshPort?: pulumi.Input<string>;
    sshUser?: pulumi.Input<string>;
    sshUserGroup?: pulumi.Input<string>;
    tags?: pulumi.Input<pulumi.Input<string>[]>;
    username?: pulumi.Input<string>;
    vappIpAllocationPolicy?: pulumi.Input<string>;
    vappIpProtocol?: pulumi.Input<string>;
    vappProperties?: pulumi.Input<pulumi.Input<string>[]>;
    vappTransport?: pulumi.Input<string>;
    vcenter?: pulumi.Input<string>;
    vcenterPort?: pulumi.Input<string>;
}

export interface NotifierPagerdutyConfig {
    proxyUrl?: pulumi.Input<string>;
    serviceKey: pulumi.Input<string>;
}

export interface NotifierSlackConfig {
    defaultRecipient: pulumi.Input<string>;
    proxyUrl?: pulumi.Input<string>;
    url: pulumi.Input<string>;
}

export interface NotifierSmtpConfig {
    defaultRecipient: pulumi.Input<string>;
    host: pulumi.Input<string>;
    password?: pulumi.Input<string>;
    port: pulumi.Input<number>;
    sender: pulumi.Input<string>;
    tls?: pulumi.Input<boolean>;
    username?: pulumi.Input<string>;
}

export interface NotifierWebhookConfig {
    proxyUrl?: pulumi.Input<string>;
    url: pulumi.Input<string>;
}

export interface NotifierWechatConfig {
    agent: pulumi.Input<string>;
    corp: pulumi.Input<string>;
    defaultRecipient: pulumi.Input<string>;
    proxyUrl?: pulumi.Input<string>;
    recipientType?: pulumi.Input<string>;
    secret: pulumi.Input<string>;
}

export interface PodSecurityPolicyTemplateAllowedCsiDriver {
    name: pulumi.Input<string>;
}

export interface PodSecurityPolicyTemplateAllowedFlexVolume {
    driver: pulumi.Input<string>;
}

export interface PodSecurityPolicyTemplateAllowedHostPath {
    pathPrefix: pulumi.Input<string>;
    readOnly?: pulumi.Input<boolean>;
}

export interface PodSecurityPolicyTemplateFsGroup {
    ranges?: pulumi.Input<pulumi.Input<inputs.PodSecurityPolicyTemplateFsGroupRange>[]>;
    rule?: pulumi.Input<string>;
}

export interface PodSecurityPolicyTemplateFsGroupRange {
    max: pulumi.Input<number>;
    min: pulumi.Input<number>;
}

export interface PodSecurityPolicyTemplateHostPort {
    max: pulumi.Input<number>;
    min: pulumi.Input<number>;
}

export interface PodSecurityPolicyTemplateRunAsGroup {
    ranges?: pulumi.Input<pulumi.Input<inputs.PodSecurityPolicyTemplateRunAsGroupRange>[]>;
    rule: pulumi.Input<string>;
}

export interface PodSecurityPolicyTemplateRunAsGroupRange {
    max: pulumi.Input<number>;
    min: pulumi.Input<number>;
}

export interface PodSecurityPolicyTemplateRunAsUser {
    ranges?: pulumi.Input<pulumi.Input<inputs.PodSecurityPolicyTemplateRunAsUserRange>[]>;
    rule: pulumi.Input<string>;
}

export interface PodSecurityPolicyTemplateRunAsUserRange {
    max: pulumi.Input<number>;
    min: pulumi.Input<number>;
}

export interface PodSecurityPolicyTemplateRuntimeClass {
    allowedRuntimeClassNames: pulumi.Input<pulumi.Input<string>[]>;
    defaultRuntimeClassName?: pulumi.Input<string>;
}

export interface PodSecurityPolicyTemplateSeLinux {
    rule: pulumi.Input<string>;
    seLinuxOption?: pulumi.Input<inputs.PodSecurityPolicyTemplateSeLinuxSeLinuxOption>;
}

export interface PodSecurityPolicyTemplateSeLinuxSeLinuxOption {
    level?: pulumi.Input<string>;
    role?: pulumi.Input<string>;
    type?: pulumi.Input<string>;
    user?: pulumi.Input<string>;
}

export interface PodSecurityPolicyTemplateSupplementalGroup {
    ranges?: pulumi.Input<pulumi.Input<inputs.PodSecurityPolicyTemplateSupplementalGroupRange>[]>;
    rule?: pulumi.Input<string>;
}

export interface PodSecurityPolicyTemplateSupplementalGroupRange {
    max: pulumi.Input<number>;
    min: pulumi.Input<number>;
}

export interface ProjectAlertGroupRecipient {
    defaultRecipient?: pulumi.Input<boolean>;
    notifierId: pulumi.Input<string>;
    notifierType?: pulumi.Input<string>;
    recipient?: pulumi.Input<string>;
}

export interface ProjectAlertRuleMetricRule {
    comparison?: pulumi.Input<string>;
    description?: pulumi.Input<string>;
    duration: pulumi.Input<string>;
    expression: pulumi.Input<string>;
    thresholdValue: pulumi.Input<number>;
}

export interface ProjectAlertRulePodRule {
    condition?: pulumi.Input<string>;
    podId: pulumi.Input<string>;
    restartIntervalSeconds?: pulumi.Input<number>;
    restartTimes?: pulumi.Input<number>;
}

export interface ProjectAlertRuleWorkloadRule {
    availablePercentage?: pulumi.Input<number>;
    selector?: pulumi.Input<{[key: string]: any}>;
    workloadId?: pulumi.Input<string>;
}

export interface ProjectContainerResourceLimit {
    limitsCpu?: pulumi.Input<string>;
    limitsMemory?: pulumi.Input<string>;
    requestsCpu?: pulumi.Input<string>;
    requestsMemory?: pulumi.Input<string>;
}

export interface ProjectLoggingCustomTargetConfig {
    certificate?: pulumi.Input<string>;
    clientCert?: pulumi.Input<string>;
    clientKey?: pulumi.Input<string>;
    content: pulumi.Input<string>;
}

export interface ProjectLoggingElasticsearchConfig {
    authPassword?: pulumi.Input<string>;
    authUsername?: pulumi.Input<string>;
    certificate?: pulumi.Input<string>;
    clientCert?: pulumi.Input<string>;
    clientKey?: pulumi.Input<string>;
    clientKeyPass?: pulumi.Input<string>;
    dateFormat?: pulumi.Input<string>;
    endpoint: pulumi.Input<string>;
    indexPrefix?: pulumi.Input<string>;
    sslVerify?: pulumi.Input<boolean>;
    sslVersion?: pulumi.Input<string>;
}

export interface ProjectLoggingFluentdConfig {
    certificate?: pulumi.Input<string>;
    compress?: pulumi.Input<boolean>;
    enableTls?: pulumi.Input<boolean>;
    fluentServers: pulumi.Input<pulumi.Input<inputs.ProjectLoggingFluentdConfigFluentServer>[]>;
}

export interface ProjectLoggingFluentdConfigFluentServer {
    endpoint: pulumi.Input<string>;
    hostname?: pulumi.Input<string>;
    password?: pulumi.Input<string>;
    sharedKey?: pulumi.Input<string>;
    standby?: pulumi.Input<boolean>;
    username?: pulumi.Input<string>;
    weight?: pulumi.Input<number>;
}

export interface ProjectLoggingKafkaConfig {
    brokerEndpoints?: pulumi.Input<pulumi.Input<string>[]>;
    certificate?: pulumi.Input<string>;
    clientCert?: pulumi.Input<string>;
    clientKey?: pulumi.Input<string>;
    topic: pulumi.Input<string>;
    zookeeperEndpoint?: pulumi.Input<string>;
}

export interface ProjectLoggingSplunkConfig {
    certificate?: pulumi.Input<string>;
    clientCert?: pulumi.Input<string>;
    clientKey?: pulumi.Input<string>;
    clientKeyPass?: pulumi.Input<string>;
    endpoint: pulumi.Input<string>;
    index?: pulumi.Input<string>;
    source?: pulumi.Input<string>;
    sslVerify?: pulumi.Input<boolean>;
    token: pulumi.Input<string>;
}

export interface ProjectLoggingSyslogConfig {
    certificate?: pulumi.Input<string>;
    clientCert?: pulumi.Input<string>;
    clientKey?: pulumi.Input<string>;
    enableTls?: pulumi.Input<boolean>;
    endpoint: pulumi.Input<string>;
    program?: pulumi.Input<string>;
    protocol?: pulumi.Input<string>;
    severity?: pulumi.Input<string>;
    sslVerify?: pulumi.Input<boolean>;
    token?: pulumi.Input<string>;
}

export interface ProjectProjectMonitoringInput {
    answers?: pulumi.Input<{[key: string]: any}>;
    version?: pulumi.Input<string>;
}

export interface ProjectResourceQuota {
    namespaceDefaultLimit: pulumi.Input<inputs.ProjectResourceQuotaNamespaceDefaultLimit>;
    projectLimit: pulumi.Input<inputs.ProjectResourceQuotaProjectLimit>;
}

export interface ProjectResourceQuotaNamespaceDefaultLimit {
    configMaps?: pulumi.Input<string>;
    limitsCpu?: pulumi.Input<string>;
    limitsMemory?: pulumi.Input<string>;
    persistentVolumeClaims?: pulumi.Input<string>;
    pods?: pulumi.Input<string>;
    replicationControllers?: pulumi.Input<string>;
    requestsCpu?: pulumi.Input<string>;
    requestsMemory?: pulumi.Input<string>;
    requestsStorage?: pulumi.Input<string>;
    secrets?: pulumi.Input<string>;
    services?: pulumi.Input<string>;
    servicesLoadBalancers?: pulumi.Input<string>;
    servicesNodePorts?: pulumi.Input<string>;
}

export interface ProjectResourceQuotaProjectLimit {
    configMaps?: pulumi.Input<string>;
    limitsCpu?: pulumi.Input<string>;
    limitsMemory?: pulumi.Input<string>;
    persistentVolumeClaims?: pulumi.Input<string>;
    pods?: pulumi.Input<string>;
    replicationControllers?: pulumi.Input<string>;
    requestsCpu?: pulumi.Input<string>;
    requestsMemory?: pulumi.Input<string>;
    requestsStorage?: pulumi.Input<string>;
    secrets?: pulumi.Input<string>;
    services?: pulumi.Input<string>;
    servicesLoadBalancers?: pulumi.Input<string>;
    servicesNodePorts?: pulumi.Input<string>;
}

export interface RegistryRegistry {
    address: pulumi.Input<string>;
    password?: pulumi.Input<string>;
    username?: pulumi.Input<string>;
}

export interface RoleTempalteRule {
    apiGroups?: pulumi.Input<pulumi.Input<string>[]>;
    nonResourceUrls?: pulumi.Input<pulumi.Input<string>[]>;
    resourceNames?: pulumi.Input<pulumi.Input<string>[]>;
    resources?: pulumi.Input<pulumi.Input<string>[]>;
    verbs?: pulumi.Input<pulumi.Input<string>[]>;
}
