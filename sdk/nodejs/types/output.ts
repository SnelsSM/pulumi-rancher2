// *** WARNING: this file was generated by the Pulumi Terraform Bridge (tfgen) Tool. ***
// *** Do not edit by hand unless you're certain you know what you are doing! ***

import * as pulumi from "@pulumi/pulumi";
import * as inputs from "../types/input";
import * as outputs from "../types/output";

export interface CloudCredentialAmazonec2CredentialConfig {
    accessKey: string;
    secretKey: string;
}

export interface CloudCredentialAzureCredentialConfig {
    clientId: string;
    clientSecret: string;
    subscriptionId: string;
}

export interface CloudCredentialDigitaloceanCredentialConfig {
    accessToken: string;
}

export interface CloudCredentialLinodeCredentialConfig {
    token: string;
}

export interface CloudCredentialOpenstackCredentialConfig {
    password: string;
}

export interface CloudCredentialVsphereCredentialConfig {
    password: string;
    username: string;
    vcenter: string;
    vcenterPort?: string;
}

export interface ClusterAksConfig {
    aadServerAppSecret?: string;
    aadTenantId?: string;
    addClientAppId?: string;
    addServerAppId?: string;
    adminUsername?: string;
    agentDnsPrefix: string;
    agentOsDiskSize?: number;
    agentPoolName?: string;
    agentStorageProfile?: string;
    agentVmSize?: string;
    authBaseUrl?: string;
    baseUrl?: string;
    clientId: string;
    clientSecret: string;
    count?: number;
    dnsServiceIp?: string;
    dockerBridgeCidr?: string;
    enableHttpApplicationRouting?: boolean;
    enableMonitoring?: boolean;
    kubernetesVersion: string;
    location?: string;
    logAnalyticsWorkspace?: string;
    logAnalyticsWorkspaceResourceGroup?: string;
    masterDnsPrefix: string;
    maxPods?: number;
    networkPlugin?: string;
    networkPolicy?: string;
    podCidr?: string;
    resourceGroup: string;
    serviceCidr?: string;
    sshPublicKeyContents: string;
    subnet: string;
    subscriptionId: string;
    tag: {[key: string]: any};
    tenantId: string;
    virtualNetwork: string;
    virtualNetworkResourceGroup: string;
}

export interface ClusterAlertGroupRecipient {
    defaultRecipient?: boolean;
    notifierId: string;
    notifierType: string;
    recipient: string;
}

export interface ClusterAlertRuleEventRule {
    eventType?: string;
    resourceKind: string;
}

export interface ClusterAlertRuleMetricRule {
    comparison?: string;
    description?: string;
    duration: string;
    expression: string;
    thresholdValue: number;
}

export interface ClusterAlertRuleNodeRule {
    condition?: string;
    cpuThreshold?: number;
    memThreshold?: number;
    nodeId?: string;
    selector?: {[key: string]: any};
}

export interface ClusterAlertRuleSystemServiceRule {
    condition?: string;
}

export interface ClusterAlterGroupRecipient {
    defaultRecipient?: boolean;
    notifierId: string;
    notifierType: string;
    recipient: string;
}

export interface ClusterAlterRuleEventRule {
    eventType?: string;
    resourceKind: string;
}

export interface ClusterAlterRuleMetricRule {
    comparison?: string;
    description?: string;
    duration: string;
    expression: string;
    thresholdValue: number;
}

export interface ClusterAlterRuleNodeRule {
    condition?: string;
    cpuThreshold?: number;
    memThreshold?: number;
    nodeId?: string;
    selector?: {[key: string]: any};
}

export interface ClusterAlterRuleSystemServiceRule {
    condition?: string;
}

export interface ClusterClusterAuthEndpoint {
    caCerts?: string;
    enabled?: boolean;
    fqdn?: string;
}

export interface ClusterClusterMonitoringInput {
    answers?: {[key: string]: any};
    version?: string;
}

export interface ClusterClusterRegistrationToken {
    annotations: {[key: string]: any};
    clusterId: string;
    command: string;
    id: string;
    insecureCommand: string;
    labels: {[key: string]: any};
    manifestUrl: string;
    name: string;
    nodeCommand: string;
    token: string;
    windowsNodeCommand: string;
}

export interface ClusterClusterTemplateAnswers {
    clusterId: string;
    projectId: string;
    values: {[key: string]: any};
}

export interface ClusterClusterTemplateQuestion {
    default: string;
    required?: boolean;
    type?: string;
    variable: string;
}

export interface ClusterEksConfig {
    accessKey: string;
    ami?: string;
    associateWorkerNodePublicIp?: boolean;
    desiredNodes?: number;
    instanceType?: string;
    keyPairName?: string;
    kubernetesVersion: string;
    maximumNodes?: number;
    minimumNodes?: number;
    nodeVolumeSize?: number;
    region?: string;
    secretKey: string;
    securityGroups?: string[];
    serviceRole?: string;
    sessionToken?: string;
    subnets?: string[];
    userData: string;
    virtualNetwork?: string;
}

export interface ClusterGkeConfig {
    clusterIpv4Cidr: string;
    credential: string;
    description?: string;
    diskSizeGb?: number;
    diskType: string;
    enableAlphaFeature?: boolean;
    enableAutoRepair?: boolean;
    enableAutoUpgrade?: boolean;
    enableHorizontalPodAutoscaling?: boolean;
    enableHttpLoadBalancing?: boolean;
    enableKubernetesDashboard?: boolean;
    enableLegacyAbac?: boolean;
    enableMasterAuthorizedNetwork?: boolean;
    enableNetworkPolicyConfig?: boolean;
    enableNodepoolAutoscaling?: boolean;
    enablePrivateEndpoint?: boolean;
    enablePrivateNodes?: boolean;
    enableStackdriverLogging?: boolean;
    enableStackdriverMonitoring?: boolean;
    imageType: string;
    ipPolicyClusterIpv4CidrBlock: string;
    ipPolicyClusterSecondaryRangeName: string;
    ipPolicyCreateSubnetwork?: boolean;
    ipPolicyNodeIpv4CidrBlock: string;
    ipPolicyServicesIpv4CidrBlock: string;
    ipPolicyServicesSecondaryRangeName: string;
    ipPolicySubnetworkName: string;
    issueClientCertificate?: boolean;
    kubernetesDashboard?: boolean;
    labels: {[key: string]: any};
    localSsdCount?: number;
    locations: string[];
    machineType: string;
    maintenanceWindow: string;
    masterAuthorizedNetworkCidrBlocks?: string[];
    masterIpv4CidrBlock: string;
    masterVersion: string;
    maxNodeCount?: number;
    minNodeCount?: number;
    network: string;
    nodeCount?: number;
    nodePool: string;
    nodeVersion: string;
    oauthScopes: string[];
    preemptible?: boolean;
    projectId: string;
    region?: string;
    resourceLabels: {[key: string]: any};
    serviceAccount: string;
    subNetwork: string;
    taints?: string[];
    useIpAliases?: boolean;
    zone?: string;
}

export interface ClusterK3sConfig {
    upgradeStrategy: outputs.ClusterK3sConfigUpgradeStrategy;
    version: string;
}

export interface ClusterK3sConfigUpgradeStrategy {
    drainServerNodes?: boolean;
    drainWorkerNodes?: boolean;
    serverConcurrency?: number;
    workerConcurrency?: number;
}

export interface ClusterLoggingCustomTargetConfig {
    certificate?: string;
    clientCert?: string;
    clientKey?: string;
    content: string;
}

export interface ClusterLoggingElasticsearchConfig {
    authPassword?: string;
    authUsername?: string;
    certificate?: string;
    clientCert?: string;
    clientKey?: string;
    clientKeyPass?: string;
    dateFormat?: string;
    endpoint: string;
    indexPrefix?: string;
    sslVerify: boolean;
    sslVersion?: string;
}

export interface ClusterLoggingFluentdConfig {
    certificate?: string;
    compress?: boolean;
    enableTls?: boolean;
    fluentServers: outputs.ClusterLoggingFluentdConfigFluentServer[];
}

export interface ClusterLoggingFluentdConfigFluentServer {
    endpoint: string;
    hostname?: string;
    password?: string;
    sharedKey?: string;
    standby?: boolean;
    username?: string;
    weight?: number;
}

export interface ClusterLoggingKafkaConfig {
    brokerEndpoints?: string[];
    certificate?: string;
    clientCert?: string;
    clientKey?: string;
    topic: string;
    zookeeperEndpoint?: string;
}

export interface ClusterLoggingSplunkConfig {
    certificate?: string;
    clientCert?: string;
    clientKey?: string;
    clientKeyPass?: string;
    endpoint: string;
    index?: string;
    source?: string;
    sslVerify: boolean;
    token: string;
}

export interface ClusterLoggingSyslogConfig {
    certificate?: string;
    clientCert?: string;
    clientKey?: string;
    enableTls?: boolean;
    endpoint: string;
    program?: string;
    protocol?: string;
    severity?: string;
    sslVerify: boolean;
    token?: string;
}

export interface ClusterRkeConfig {
    addonJobTimeout: number;
    addons?: string;
    addonsIncludes?: string[];
    authentication: outputs.ClusterRkeConfigAuthentication;
    authorization: outputs.ClusterRkeConfigAuthorization;
    bastionHost: outputs.ClusterRkeConfigBastionHost;
    cloudProvider: outputs.ClusterRkeConfigCloudProvider;
    dns: outputs.ClusterRkeConfigDns;
    ignoreDockerVersion?: boolean;
    ingress: outputs.ClusterRkeConfigIngress;
    kubernetesVersion: string;
    monitoring: outputs.ClusterRkeConfigMonitoring;
    network: outputs.ClusterRkeConfigNetwork;
    nodes?: outputs.ClusterRkeConfigNode[];
    prefixPath: string;
    privateRegistries?: outputs.ClusterRkeConfigPrivateRegistry[];
    services: outputs.ClusterRkeConfigServices;
    sshAgentAuth?: boolean;
    sshCertPath: string;
    sshKeyPath: string;
    upgradeStrategy: outputs.ClusterRkeConfigUpgradeStrategy;
}

export interface ClusterRkeConfigAuthentication {
    sans: string[];
    strategy: string;
}

export interface ClusterRkeConfigAuthorization {
    mode?: string;
    options: {[key: string]: any};
}

export interface ClusterRkeConfigBastionHost {
    address: string;
    port?: string;
    sshAgentAuth?: boolean;
    sshKey: string;
    sshKeyPath: string;
    user: string;
}

export interface ClusterRkeConfigCloudProvider {
    awsCloudProvider?: outputs.ClusterRkeConfigCloudProviderAwsCloudProvider;
    azureCloudProvider?: outputs.ClusterRkeConfigCloudProviderAzureCloudProvider;
    customCloudProvider: string;
    name: string;
    openstackCloudProvider?: outputs.ClusterRkeConfigCloudProviderOpenstackCloudProvider;
    vsphereCloudProvider?: outputs.ClusterRkeConfigCloudProviderVsphereCloudProvider;
}

export interface ClusterRkeConfigCloudProviderAwsCloudProvider {
    global: outputs.ClusterRkeConfigCloudProviderAwsCloudProviderGlobal;
    serviceOverrides?: outputs.ClusterRkeConfigCloudProviderAwsCloudProviderServiceOverride[];
}

export interface ClusterRkeConfigCloudProviderAwsCloudProviderGlobal {
    disableSecurityGroupIngress?: boolean;
    disableStrictZoneCheck?: boolean;
    elbSecurityGroup: string;
    kubernetesClusterId: string;
    kubernetesClusterTag: string;
    roleArn: string;
    routeTableId: string;
    subnetId: string;
    vpc: string;
    zone: string;
}

export interface ClusterRkeConfigCloudProviderAwsCloudProviderServiceOverride {
    region: string;
    service: string;
    signingMethod: string;
    signingName: string;
    signingRegion: string;
    url: string;
}

export interface ClusterRkeConfigCloudProviderAzureCloudProvider {
    aadClientCertPassword: string;
    aadClientCertPath: string;
    aadClientId: string;
    aadClientSecret: string;
    cloud: string;
    cloudProviderBackoff: boolean;
    cloudProviderBackoffDuration: number;
    cloudProviderBackoffExponent: number;
    cloudProviderBackoffJitter: number;
    cloudProviderBackoffRetries: number;
    cloudProviderRateLimit: boolean;
    cloudProviderRateLimitBucket: number;
    cloudProviderRateLimitQps: number;
    loadBalancerSku?: string;
    location: string;
    maximumLoadBalancerRuleCount: number;
    primaryAvailabilitySetName: string;
    primaryScaleSetName: string;
    resourceGroup: string;
    routeTableName: string;
    securityGroupName: string;
    subnetName: string;
    subscriptionId: string;
    tenantId: string;
    useInstanceMetadata: boolean;
    useManagedIdentityExtension: boolean;
    vmType: string;
    vnetName: string;
    vnetResourceGroup: string;
}

export interface ClusterRkeConfigCloudProviderOpenstackCloudProvider {
    blockStorage: outputs.ClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorage;
    global: outputs.ClusterRkeConfigCloudProviderOpenstackCloudProviderGlobal;
    loadBalancer: outputs.ClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer;
    metadata: outputs.ClusterRkeConfigCloudProviderOpenstackCloudProviderMetadata;
    route: outputs.ClusterRkeConfigCloudProviderOpenstackCloudProviderRoute;
}

export interface ClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorage {
    bsVersion: string;
    ignoreVolumeAz: boolean;
    trustDevicePath: boolean;
}

export interface ClusterRkeConfigCloudProviderOpenstackCloudProviderGlobal {
    authUrl: string;
    caFile: string;
    domainId: string;
    domainName: string;
    password: string;
    region: string;
    tenantId: string;
    tenantName: string;
    trustId: string;
    username: string;
}

export interface ClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer {
    createMonitor: boolean;
    floatingNetworkId: string;
    lbMethod: string;
    lbProvider: string;
    lbVersion: string;
    manageSecurityGroups: boolean;
    monitorDelay?: string;
    monitorMaxRetries?: number;
    monitorTimeout?: string;
    subnetId: string;
    useOctavia: boolean;
}

export interface ClusterRkeConfigCloudProviderOpenstackCloudProviderMetadata {
    requestTimeout: number;
    searchOrder: string;
}

export interface ClusterRkeConfigCloudProviderOpenstackCloudProviderRoute {
    routerId: string;
}

export interface ClusterRkeConfigCloudProviderVsphereCloudProvider {
    disk: outputs.ClusterRkeConfigCloudProviderVsphereCloudProviderDisk;
    global: outputs.ClusterRkeConfigCloudProviderVsphereCloudProviderGlobal;
    network: outputs.ClusterRkeConfigCloudProviderVsphereCloudProviderNetwork;
    virtualCenters: outputs.ClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenter[];
    workspace: outputs.ClusterRkeConfigCloudProviderVsphereCloudProviderWorkspace;
}

export interface ClusterRkeConfigCloudProviderVsphereCloudProviderDisk {
    scsiControllerType: string;
}

export interface ClusterRkeConfigCloudProviderVsphereCloudProviderGlobal {
    datacenters: string;
    insecureFlag: boolean;
    password: string;
    port: string;
    soapRoundtripCount: number;
    user: string;
}

export interface ClusterRkeConfigCloudProviderVsphereCloudProviderNetwork {
    publicNetwork: string;
}

export interface ClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenter {
    datacenters: string;
    name: string;
    password: string;
    port: string;
    soapRoundtripCount: number;
    user: string;
}

export interface ClusterRkeConfigCloudProviderVsphereCloudProviderWorkspace {
    datacenter: string;
    defaultDatastore: string;
    folder: string;
    resourcepoolPath: string;
    server: string;
}

export interface ClusterRkeConfigDns {
    nodeSelector: {[key: string]: any};
    nodelocal?: outputs.ClusterRkeConfigDnsNodelocal;
    provider?: string;
    reverseCidrs: string[];
    upstreamNameservers: string[];
}

export interface ClusterRkeConfigDnsNodelocal {
    ipAddress?: string;
    nodeSelector?: {[key: string]: any};
}

export interface ClusterRkeConfigIngress {
    dnsPolicy: string;
    extraArgs: {[key: string]: any};
    nodeSelector: {[key: string]: any};
    options: {[key: string]: any};
    provider: string;
}

export interface ClusterRkeConfigMonitoring {
    nodeSelector?: {[key: string]: any};
    options: {[key: string]: any};
    provider: string;
    replicas: number;
    updateStrategy?: outputs.ClusterRkeConfigMonitoringUpdateStrategy;
}

export interface ClusterRkeConfigMonitoringUpdateStrategy {
    rollingUpdate?: outputs.ClusterRkeConfigMonitoringUpdateStrategyRollingUpdate;
    strategy?: string;
}

export interface ClusterRkeConfigMonitoringUpdateStrategyRollingUpdate {
    maxSurge?: number;
    maxUnavailable?: number;
}

export interface ClusterRkeConfigNetwork {
    calicoNetworkProvider?: outputs.ClusterRkeConfigNetworkCalicoNetworkProvider;
    canalNetworkProvider?: outputs.ClusterRkeConfigNetworkCanalNetworkProvider;
    flannelNetworkProvider?: outputs.ClusterRkeConfigNetworkFlannelNetworkProvider;
    mtu?: number;
    options: {[key: string]: any};
    plugin: string;
    weaveNetworkProvider?: outputs.ClusterRkeConfigNetworkWeaveNetworkProvider;
}

export interface ClusterRkeConfigNetworkCalicoNetworkProvider {
    cloudProvider: string;
}

export interface ClusterRkeConfigNetworkCanalNetworkProvider {
    iface: string;
}

export interface ClusterRkeConfigNetworkFlannelNetworkProvider {
    iface: string;
}

export interface ClusterRkeConfigNetworkWeaveNetworkProvider {
    password: string;
}

export interface ClusterRkeConfigNode {
    address: string;
    dockerSocket: string;
    hostnameOverride?: string;
    internalAddress?: string;
    labels?: {[key: string]: any};
    nodeId?: string;
    port?: string;
    roles: string[];
    sshAgentAuth?: boolean;
    sshKey: string;
    sshKeyPath: string;
    user: string;
}

export interface ClusterRkeConfigPrivateRegistry {
    isDefault?: boolean;
    password?: string;
    url: string;
    user?: string;
}

export interface ClusterRkeConfigServices {
    etcd: outputs.ClusterRkeConfigServicesEtcd;
    kubeApi: outputs.ClusterRkeConfigServicesKubeApi;
    kubeController: outputs.ClusterRkeConfigServicesKubeController;
    kubelet: outputs.ClusterRkeConfigServicesKubelet;
    kubeproxy: outputs.ClusterRkeConfigServicesKubeproxy;
    scheduler: outputs.ClusterRkeConfigServicesScheduler;
}

export interface ClusterRkeConfigServicesEtcd {
    backupConfig: outputs.ClusterRkeConfigServicesEtcdBackupConfig;
    caCert: string;
    cert: string;
    creation: string;
    externalUrls?: string[];
    extraArgs: {[key: string]: any};
    extraBinds?: string[];
    extraEnvs?: string[];
    gid?: number;
    image: string;
    key: string;
    path: string;
    retention: string;
    snapshot: boolean;
    uid?: number;
}

export interface ClusterRkeConfigServicesEtcdBackupConfig {
    enabled?: boolean;
    intervalHours?: number;
    retention?: number;
    s3BackupConfig?: outputs.ClusterRkeConfigServicesEtcdBackupConfigS3BackupConfig;
    safeTimestamp?: boolean;
}

export interface ClusterRkeConfigServicesEtcdBackupConfigS3BackupConfig {
    accessKey?: string;
    bucketName: string;
    customCa?: string;
    endpoint: string;
    folder?: string;
    region?: string;
    secretKey?: string;
}

export interface ClusterRkeConfigServicesKubeApi {
    admissionConfiguration?: {[key: string]: any};
    alwaysPullImages?: boolean;
    auditLog?: outputs.ClusterRkeConfigServicesKubeApiAuditLog;
    eventRateLimit?: outputs.ClusterRkeConfigServicesKubeApiEventRateLimit;
    extraArgs: {[key: string]: any};
    extraBinds?: string[];
    extraEnvs?: string[];
    image: string;
    podSecurityPolicy?: boolean;
    secretsEncryptionConfig?: outputs.ClusterRkeConfigServicesKubeApiSecretsEncryptionConfig;
    serviceClusterIpRange: string;
    serviceNodePortRange: string;
}

export interface ClusterRkeConfigServicesKubeApiAuditLog {
    configuration: outputs.ClusterRkeConfigServicesKubeApiAuditLogConfiguration;
    enabled?: boolean;
}

export interface ClusterRkeConfigServicesKubeApiAuditLogConfiguration {
    format?: string;
    maxAge?: number;
    maxBackup?: number;
    maxSize?: number;
    path?: string;
    policy: string;
}

export interface ClusterRkeConfigServicesKubeApiEventRateLimit {
    configuration: string;
    enabled?: boolean;
}

export interface ClusterRkeConfigServicesKubeApiSecretsEncryptionConfig {
    customConfig?: string;
    enabled?: boolean;
}

export interface ClusterRkeConfigServicesKubeController {
    clusterCidr: string;
    extraArgs: {[key: string]: any};
    extraBinds?: string[];
    extraEnvs?: string[];
    image: string;
    serviceClusterIpRange: string;
}

export interface ClusterRkeConfigServicesKubelet {
    clusterDnsServer: string;
    clusterDomain: string;
    extraArgs: {[key: string]: any};
    extraBinds?: string[];
    extraEnvs?: string[];
    failSwapOn: boolean;
    generateServingCertificate?: boolean;
    image: string;
    infraContainerImage: string;
}

export interface ClusterRkeConfigServicesKubeproxy {
    extraArgs: {[key: string]: any};
    extraBinds?: string[];
    extraEnvs?: string[];
    image: string;
}

export interface ClusterRkeConfigServicesScheduler {
    extraArgs: {[key: string]: any};
    extraBinds?: string[];
    extraEnvs?: string[];
    image: string;
}

export interface ClusterRkeConfigUpgradeStrategy {
    drain?: boolean;
    drainInput: outputs.ClusterRkeConfigUpgradeStrategyDrainInput;
    maxUnavailableControlplane?: string;
    maxUnavailableWorker?: string;
}

export interface ClusterRkeConfigUpgradeStrategyDrainInput {
    deleteLocalData?: boolean;
    force?: boolean;
    gracePeriod?: number;
    ignoreDaemonSets?: boolean;
    timeout?: number;
}

export interface ClusterScheduledClusterScan {
    enabled?: boolean;
    scanConfig: outputs.ClusterScheduledClusterScanScanConfig;
    scheduleConfig: outputs.ClusterScheduledClusterScanScheduleConfig;
}

export interface ClusterScheduledClusterScanScanConfig {
    cisScanConfig: outputs.ClusterScheduledClusterScanScanConfigCisScanConfig;
}

export interface ClusterScheduledClusterScanScanConfigCisScanConfig {
    debugMaster?: boolean;
    debugWorker?: boolean;
    overrideBenchmarkVersion?: string;
    overrideSkips?: string[];
    profile?: string;
}

export interface ClusterScheduledClusterScanScheduleConfig {
    cronSchedule: string;
    retention: number;
}

export interface ClusterTemplateMember {
    accessType?: string;
    groupPrincipalId?: string;
    userPrincipalId?: string;
}

export interface ClusterTemplateTemplateRevision {
    annotations: {[key: string]: any};
    clusterConfig: outputs.ClusterTemplateTemplateRevisionClusterConfig;
    clusterTemplateId: string;
    default?: boolean;
    enabled?: boolean;
    id: string;
    labels: {[key: string]: any};
    name: string;
    questions?: outputs.ClusterTemplateTemplateRevisionQuestion[];
}

export interface ClusterTemplateTemplateRevisionClusterConfig {
    clusterAuthEndpoint: outputs.ClusterTemplateTemplateRevisionClusterConfigClusterAuthEndpoint;
    defaultClusterRoleForProjectMembers: string;
    defaultPodSecurityPolicyTemplateId: string;
    desiredAgentImage: string;
    desiredAuthImage: string;
    dockerRootDir: string;
    enableClusterAlerting?: boolean;
    enableClusterMonitoring?: boolean;
    enableNetworkPolicy?: boolean;
    rkeConfig: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfig;
    scheduledClusterScan?: outputs.ClusterTemplateTemplateRevisionClusterConfigScheduledClusterScan;
    windowsPreferedCluster?: boolean;
}

export interface ClusterTemplateTemplateRevisionClusterConfigClusterAuthEndpoint {
    caCerts?: string;
    enabled?: boolean;
    fqdn?: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfig {
    addonJobTimeout: number;
    addons?: string;
    addonsIncludes?: string[];
    authentication: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthentication;
    authorization: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthorization;
    bastionHost: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigBastionHost;
    cloudProvider: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProvider;
    dns: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigDns;
    ignoreDockerVersion?: boolean;
    ingress: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngress;
    kubernetesVersion: string;
    monitoring: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoring;
    network: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetwork;
    nodes?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigNode[];
    prefixPath: string;
    privateRegistries?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistry[];
    services: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServices;
    sshAgentAuth?: boolean;
    sshCertPath: string;
    sshKeyPath: string;
    upgradeStrategy: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategy;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthentication {
    sans: string[];
    strategy: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthorization {
    mode?: string;
    options: {[key: string]: any};
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigBastionHost {
    address: string;
    port?: string;
    sshAgentAuth?: boolean;
    sshKey: string;
    sshKeyPath: string;
    user: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProvider {
    awsCloudProvider?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProvider;
    azureCloudProvider?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAzureCloudProvider;
    customCloudProvider: string;
    name: string;
    openstackCloudProvider?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProvider;
    vsphereCloudProvider?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProvider;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProvider {
    global: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderGlobal;
    serviceOverrides?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderServiceOverride[];
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderGlobal {
    disableSecurityGroupIngress?: boolean;
    disableStrictZoneCheck?: boolean;
    elbSecurityGroup: string;
    kubernetesClusterId: string;
    kubernetesClusterTag: string;
    roleArn: string;
    routeTableId: string;
    subnetId: string;
    vpc: string;
    zone: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderServiceOverride {
    region: string;
    service: string;
    signingMethod: string;
    signingName: string;
    signingRegion: string;
    url: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAzureCloudProvider {
    aadClientCertPassword: string;
    aadClientCertPath: string;
    aadClientId: string;
    aadClientSecret: string;
    cloud: string;
    cloudProviderBackoff: boolean;
    cloudProviderBackoffDuration: number;
    cloudProviderBackoffExponent: number;
    cloudProviderBackoffJitter: number;
    cloudProviderBackoffRetries: number;
    cloudProviderRateLimit: boolean;
    cloudProviderRateLimitBucket: number;
    cloudProviderRateLimitQps: number;
    loadBalancerSku?: string;
    location: string;
    maximumLoadBalancerRuleCount: number;
    primaryAvailabilitySetName: string;
    primaryScaleSetName: string;
    resourceGroup: string;
    routeTableName: string;
    securityGroupName: string;
    subnetName: string;
    subscriptionId: string;
    tenantId: string;
    useInstanceMetadata: boolean;
    useManagedIdentityExtension: boolean;
    vmType: string;
    vnetName: string;
    vnetResourceGroup: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProvider {
    blockStorage: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderBlockStorage;
    global: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderGlobal;
    loadBalancer: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer;
    metadata: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderMetadata;
    route: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderRoute;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderBlockStorage {
    bsVersion: string;
    ignoreVolumeAz: boolean;
    trustDevicePath: boolean;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderGlobal {
    authUrl: string;
    caFile: string;
    domainId: string;
    domainName: string;
    password: string;
    region: string;
    tenantId: string;
    tenantName: string;
    trustId: string;
    username: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer {
    createMonitor: boolean;
    floatingNetworkId: string;
    lbMethod: string;
    lbProvider: string;
    lbVersion: string;
    manageSecurityGroups: boolean;
    monitorDelay?: string;
    monitorMaxRetries?: number;
    monitorTimeout?: string;
    subnetId: string;
    useOctavia: boolean;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderMetadata {
    requestTimeout: number;
    searchOrder: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderRoute {
    routerId: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProvider {
    disk: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderDisk;
    global: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderGlobal;
    network: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderNetwork;
    virtualCenters: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderVirtualCenter[];
    workspace: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderWorkspace;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderDisk {
    scsiControllerType: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderGlobal {
    datacenters: string;
    insecureFlag: boolean;
    password: string;
    port: string;
    soapRoundtripCount: number;
    user: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderNetwork {
    publicNetwork: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderVirtualCenter {
    datacenters: string;
    name: string;
    password: string;
    port: string;
    soapRoundtripCount: number;
    user: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderWorkspace {
    datacenter: string;
    defaultDatastore: string;
    folder: string;
    resourcepoolPath: string;
    server: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigDns {
    nodeSelector: {[key: string]: any};
    nodelocal?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsNodelocal;
    provider?: string;
    reverseCidrs: string[];
    upstreamNameservers: string[];
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsNodelocal {
    ipAddress?: string;
    nodeSelector?: {[key: string]: any};
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigIngress {
    dnsPolicy: string;
    extraArgs: {[key: string]: any};
    nodeSelector: {[key: string]: any};
    options: {[key: string]: any};
    provider: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoring {
    nodeSelector?: {[key: string]: any};
    options: {[key: string]: any};
    provider: string;
    replicas: number;
    updateStrategy?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategy;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategy {
    rollingUpdate?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyRollingUpdate;
    strategy?: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyRollingUpdate {
    maxSurge?: number;
    maxUnavailable?: number;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetwork {
    calicoNetworkProvider?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCalicoNetworkProvider;
    canalNetworkProvider?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCanalNetworkProvider;
    flannelNetworkProvider?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkFlannelNetworkProvider;
    mtu?: number;
    options: {[key: string]: any};
    plugin: string;
    weaveNetworkProvider?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkWeaveNetworkProvider;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCalicoNetworkProvider {
    cloudProvider: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCanalNetworkProvider {
    iface: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkFlannelNetworkProvider {
    iface: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkWeaveNetworkProvider {
    password: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigNode {
    address: string;
    dockerSocket: string;
    hostnameOverride?: string;
    internalAddress?: string;
    labels?: {[key: string]: any};
    nodeId?: string;
    port?: string;
    roles: string[];
    sshAgentAuth?: boolean;
    sshKey: string;
    sshKeyPath: string;
    user: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistry {
    isDefault?: boolean;
    password?: string;
    url: string;
    user?: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServices {
    etcd: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcd;
    kubeApi: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApi;
    kubeController: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeController;
    kubelet: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubelet;
    kubeproxy: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeproxy;
    scheduler: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesScheduler;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcd {
    backupConfig: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfig;
    caCert: string;
    cert: string;
    creation: string;
    externalUrls?: string[];
    extraArgs: {[key: string]: any};
    extraBinds?: string[];
    extraEnvs?: string[];
    gid?: number;
    image: string;
    key: string;
    path: string;
    retention: string;
    snapshot: boolean;
    uid?: number;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfig {
    enabled?: boolean;
    intervalHours?: number;
    retention?: number;
    s3BackupConfig?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfigS3BackupConfig;
    safeTimestamp?: boolean;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfigS3BackupConfig {
    accessKey?: string;
    bucketName: string;
    customCa?: string;
    endpoint: string;
    folder?: string;
    region?: string;
    secretKey?: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApi {
    admissionConfiguration?: {[key: string]: any};
    alwaysPullImages?: boolean;
    auditLog?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLog;
    eventRateLimit?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiEventRateLimit;
    extraArgs: {[key: string]: any};
    extraBinds?: string[];
    extraEnvs?: string[];
    image: string;
    podSecurityPolicy?: boolean;
    secretsEncryptionConfig?: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiSecretsEncryptionConfig;
    serviceClusterIpRange: string;
    serviceNodePortRange: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLog {
    configuration: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLogConfiguration;
    enabled?: boolean;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLogConfiguration {
    format?: string;
    maxAge?: number;
    maxBackup?: number;
    maxSize?: number;
    path?: string;
    policy: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiEventRateLimit {
    configuration: string;
    enabled?: boolean;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiSecretsEncryptionConfig {
    customConfig?: string;
    enabled?: boolean;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeController {
    clusterCidr: string;
    extraArgs: {[key: string]: any};
    extraBinds?: string[];
    extraEnvs?: string[];
    image: string;
    serviceClusterIpRange: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubelet {
    clusterDnsServer: string;
    clusterDomain: string;
    extraArgs: {[key: string]: any};
    extraBinds?: string[];
    extraEnvs?: string[];
    failSwapOn: boolean;
    generateServingCertificate?: boolean;
    image: string;
    infraContainerImage: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeproxy {
    extraArgs: {[key: string]: any};
    extraBinds?: string[];
    extraEnvs?: string[];
    image: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesScheduler {
    extraArgs: {[key: string]: any};
    extraBinds?: string[];
    extraEnvs?: string[];
    image: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategy {
    drain?: boolean;
    drainInput: outputs.ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyDrainInput;
    maxUnavailableControlplane?: string;
    maxUnavailableWorker?: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyDrainInput {
    deleteLocalData?: boolean;
    force?: boolean;
    gracePeriod?: number;
    ignoreDaemonSets?: boolean;
    timeout?: number;
}

export interface ClusterTemplateTemplateRevisionClusterConfigScheduledClusterScan {
    enabled?: boolean;
    scanConfig: outputs.ClusterTemplateTemplateRevisionClusterConfigScheduledClusterScanScanConfig;
    scheduleConfig: outputs.ClusterTemplateTemplateRevisionClusterConfigScheduledClusterScanScheduleConfig;
}

export interface ClusterTemplateTemplateRevisionClusterConfigScheduledClusterScanScanConfig {
    cisScanConfig: outputs.ClusterTemplateTemplateRevisionClusterConfigScheduledClusterScanScanConfigCisScanConfig;
}

export interface ClusterTemplateTemplateRevisionClusterConfigScheduledClusterScanScanConfigCisScanConfig {
    debugMaster?: boolean;
    debugWorker?: boolean;
    overrideBenchmarkVersion?: string;
    overrideSkips?: string[];
    profile?: string;
}

export interface ClusterTemplateTemplateRevisionClusterConfigScheduledClusterScanScheduleConfig {
    cronSchedule: string;
    retention: number;
}

export interface ClusterTemplateTemplateRevisionQuestion {
    default: string;
    required?: boolean;
    type?: string;
    variable: string;
}

export interface EtcdBackupBackupConfig {
    enabled?: boolean;
    intervalHours?: number;
    retention?: number;
    s3BackupConfig?: outputs.EtcdBackupBackupConfigS3BackupConfig;
    safeTimestamp?: boolean;
}

export interface EtcdBackupBackupConfigS3BackupConfig {
    accessKey?: string;
    bucketName: string;
    customCa?: string;
    endpoint: string;
    folder?: string;
    region?: string;
    secretKey?: string;
}

export interface GetClusterAksConfig {
    aadServerAppSecret?: string;
    aadTenantId?: string;
    addClientAppId?: string;
    addServerAppId?: string;
    adminUsername?: string;
    agentDnsPrefix: string;
    agentOsDiskSize?: number;
    agentPoolName?: string;
    agentStorageProfile?: string;
    agentVmSize?: string;
    authBaseUrl?: string;
    baseUrl?: string;
    clientId: string;
    clientSecret: string;
    count?: number;
    dnsServiceIp?: string;
    dockerBridgeCidr?: string;
    enableHttpApplicationRouting?: boolean;
    enableMonitoring?: boolean;
    kubernetesVersion: string;
    location?: string;
    logAnalyticsWorkspace?: string;
    logAnalyticsWorkspaceResourceGroup?: string;
    masterDnsPrefix: string;
    maxPods?: number;
    networkPlugin?: string;
    networkPolicy?: string;
    podCidr?: string;
    resourceGroup: string;
    serviceCidr?: string;
    sshPublicKeyContents: string;
    subnet: string;
    subscriptionId: string;
    tag: {[key: string]: any};
    tenantId: string;
    virtualNetwork: string;
    virtualNetworkResourceGroup: string;
}

export interface GetClusterAlertGroupRecipient {
    defaultRecipient?: boolean;
    notifierId: string;
    notifierType: string;
    recipient: string;
}

export interface GetClusterAlterRuleEventRule {
    eventType?: string;
    resourceKind: string;
}

export interface GetClusterAlterRuleMetricRule {
    comparison?: string;
    description?: string;
    duration: string;
    expression: string;
    thresholdValue: number;
}

export interface GetClusterAlterRuleNodeRule {
    condition?: string;
    cpuThreshold?: number;
    memThreshold?: number;
    nodeId?: string;
    selector?: {[key: string]: any};
}

export interface GetClusterAlterRuleSystemServiceRule {
    condition?: string;
}

export interface GetClusterClusterAuthEndpoint {
    caCerts?: string;
    enabled?: boolean;
    fqdn?: string;
}

export interface GetClusterClusterMonitoringInput {
    answers?: {[key: string]: any};
    version?: string;
}

export interface GetClusterClusterRegistrationToken {
    annotations: {[key: string]: any};
    clusterId: string;
    command: string;
    id: string;
    insecureCommand: string;
    labels: {[key: string]: any};
    manifestUrl: string;
    name: string;
    nodeCommand: string;
    token: string;
    windowsNodeCommand: string;
}

export interface GetClusterClusterTemplateAnswers {
    clusterId: string;
    projectId: string;
    values: {[key: string]: any};
}

export interface GetClusterClusterTemplateQuestion {
    default: string;
    required?: boolean;
    type?: string;
    variable: string;
}

export interface GetClusterEksConfig {
    accessKey: string;
    ami?: string;
    associateWorkerNodePublicIp?: boolean;
    desiredNodes?: number;
    instanceType?: string;
    keyPairName?: string;
    kubernetesVersion: string;
    maximumNodes?: number;
    minimumNodes?: number;
    nodeVolumeSize?: number;
    region?: string;
    secretKey: string;
    securityGroups?: string[];
    serviceRole?: string;
    sessionToken?: string;
    subnets?: string[];
    userData: string;
    virtualNetwork?: string;
}

export interface GetClusterGkeConfig {
    clusterIpv4Cidr: string;
    credential: string;
    description?: string;
    diskSizeGb?: number;
    diskType: string;
    enableAlphaFeature?: boolean;
    enableAutoRepair?: boolean;
    enableAutoUpgrade?: boolean;
    enableHorizontalPodAutoscaling?: boolean;
    enableHttpLoadBalancing?: boolean;
    enableKubernetesDashboard?: boolean;
    enableLegacyAbac?: boolean;
    enableMasterAuthorizedNetwork?: boolean;
    enableNetworkPolicyConfig?: boolean;
    enableNodepoolAutoscaling?: boolean;
    enablePrivateEndpoint?: boolean;
    enablePrivateNodes?: boolean;
    enableStackdriverLogging?: boolean;
    enableStackdriverMonitoring?: boolean;
    imageType: string;
    ipPolicyClusterIpv4CidrBlock: string;
    ipPolicyClusterSecondaryRangeName: string;
    ipPolicyCreateSubnetwork?: boolean;
    ipPolicyNodeIpv4CidrBlock: string;
    ipPolicyServicesIpv4CidrBlock: string;
    ipPolicyServicesSecondaryRangeName: string;
    ipPolicySubnetworkName: string;
    issueClientCertificate?: boolean;
    kubernetesDashboard?: boolean;
    labels: {[key: string]: any};
    localSsdCount?: number;
    locations: string[];
    machineType: string;
    maintenanceWindow: string;
    masterAuthorizedNetworkCidrBlocks?: string[];
    masterIpv4CidrBlock: string;
    masterVersion: string;
    maxNodeCount?: number;
    minNodeCount?: number;
    network: string;
    nodeCount?: number;
    nodePool: string;
    nodeVersion: string;
    oauthScopes: string[];
    preemptible?: boolean;
    projectId: string;
    region?: string;
    resourceLabels: {[key: string]: any};
    serviceAccount: string;
    subNetwork: string;
    taints?: string[];
    useIpAliases?: boolean;
    zone?: string;
}

export interface GetClusterK3sConfig {
    upgradeStrategy: outputs.GetClusterK3sConfigUpgradeStrategy;
    version: string;
}

export interface GetClusterK3sConfigUpgradeStrategy {
    drainServerNodes?: boolean;
    drainWorkerNodes?: boolean;
    serverConcurrency?: number;
    workerConcurrency?: number;
}

export interface GetClusterLoggingCustomTargetConfig {
    certificate?: string;
    clientCert?: string;
    clientKey?: string;
    content: string;
}

export interface GetClusterLoggingElasticsearchConfig {
    authPassword?: string;
    authUsername?: string;
    certificate?: string;
    clientCert?: string;
    clientKey?: string;
    clientKeyPass?: string;
    dateFormat?: string;
    endpoint: string;
    indexPrefix?: string;
    sslVerify: boolean;
    sslVersion?: string;
}

export interface GetClusterLoggingFluentdConfig {
    certificate?: string;
    compress?: boolean;
    enableTls?: boolean;
    fluentServers: outputs.GetClusterLoggingFluentdConfigFluentServer[];
}

export interface GetClusterLoggingFluentdConfigFluentServer {
    endpoint: string;
    hostname?: string;
    password?: string;
    sharedKey?: string;
    standby?: boolean;
    username?: string;
    weight?: number;
}

export interface GetClusterLoggingKafkaConfig {
    brokerEndpoints?: string[];
    certificate?: string;
    clientCert?: string;
    clientKey?: string;
    topic: string;
    zookeeperEndpoint?: string;
}

export interface GetClusterLoggingSplunkConfig {
    certificate?: string;
    clientCert?: string;
    clientKey?: string;
    clientKeyPass?: string;
    endpoint: string;
    index?: string;
    source?: string;
    sslVerify: boolean;
    token: string;
}

export interface GetClusterLoggingSyslogConfig {
    certificate?: string;
    clientCert?: string;
    clientKey?: string;
    enableTls?: boolean;
    endpoint: string;
    program?: string;
    protocol?: string;
    severity?: string;
    sslVerify: boolean;
    token?: string;
}

export interface GetClusterRkeConfig {
    addonJobTimeout: number;
    addons?: string;
    addonsIncludes?: string[];
    authentication: outputs.GetClusterRkeConfigAuthentication;
    authorization: outputs.GetClusterRkeConfigAuthorization;
    bastionHost: outputs.GetClusterRkeConfigBastionHost;
    cloudProvider: outputs.GetClusterRkeConfigCloudProvider;
    dns: outputs.GetClusterRkeConfigDns;
    ignoreDockerVersion?: boolean;
    ingress: outputs.GetClusterRkeConfigIngress;
    kubernetesVersion: string;
    monitoring: outputs.GetClusterRkeConfigMonitoring;
    network: outputs.GetClusterRkeConfigNetwork;
    nodes?: outputs.GetClusterRkeConfigNode[];
    prefixPath: string;
    privateRegistries?: outputs.GetClusterRkeConfigPrivateRegistry[];
    services: outputs.GetClusterRkeConfigServices;
    sshAgentAuth?: boolean;
    sshCertPath: string;
    sshKeyPath: string;
    upgradeStrategy: outputs.GetClusterRkeConfigUpgradeStrategy;
}

export interface GetClusterRkeConfigAuthentication {
    sans: string[];
    strategy: string;
}

export interface GetClusterRkeConfigAuthorization {
    mode?: string;
    options: {[key: string]: any};
}

export interface GetClusterRkeConfigBastionHost {
    address: string;
    port?: string;
    sshAgentAuth?: boolean;
    sshKey: string;
    sshKeyPath: string;
    user: string;
}

export interface GetClusterRkeConfigCloudProvider {
    awsCloudProvider?: outputs.GetClusterRkeConfigCloudProviderAwsCloudProvider;
    azureCloudProvider?: outputs.GetClusterRkeConfigCloudProviderAzureCloudProvider;
    customCloudProvider: string;
    name: string;
    openstackCloudProvider?: outputs.GetClusterRkeConfigCloudProviderOpenstackCloudProvider;
    vsphereCloudProvider?: outputs.GetClusterRkeConfigCloudProviderVsphereCloudProvider;
}

export interface GetClusterRkeConfigCloudProviderAwsCloudProvider {
    global: outputs.GetClusterRkeConfigCloudProviderAwsCloudProviderGlobal;
    serviceOverrides?: outputs.GetClusterRkeConfigCloudProviderAwsCloudProviderServiceOverride[];
}

export interface GetClusterRkeConfigCloudProviderAwsCloudProviderGlobal {
    disableSecurityGroupIngress?: boolean;
    disableStrictZoneCheck?: boolean;
    elbSecurityGroup: string;
    kubernetesClusterId: string;
    kubernetesClusterTag: string;
    roleArn: string;
    routeTableId: string;
    subnetId: string;
    vpc: string;
    zone: string;
}

export interface GetClusterRkeConfigCloudProviderAwsCloudProviderServiceOverride {
    region: string;
    service: string;
    signingMethod: string;
    signingName: string;
    signingRegion: string;
    url: string;
}

export interface GetClusterRkeConfigCloudProviderAzureCloudProvider {
    aadClientCertPassword: string;
    aadClientCertPath: string;
    aadClientId: string;
    aadClientSecret: string;
    cloud: string;
    cloudProviderBackoff: boolean;
    cloudProviderBackoffDuration: number;
    cloudProviderBackoffExponent: number;
    cloudProviderBackoffJitter: number;
    cloudProviderBackoffRetries: number;
    cloudProviderRateLimit: boolean;
    cloudProviderRateLimitBucket: number;
    cloudProviderRateLimitQps: number;
    loadBalancerSku?: string;
    location: string;
    maximumLoadBalancerRuleCount: number;
    primaryAvailabilitySetName: string;
    primaryScaleSetName: string;
    resourceGroup: string;
    routeTableName: string;
    securityGroupName: string;
    subnetName: string;
    subscriptionId: string;
    tenantId: string;
    useInstanceMetadata: boolean;
    useManagedIdentityExtension: boolean;
    vmType: string;
    vnetName: string;
    vnetResourceGroup: string;
}

export interface GetClusterRkeConfigCloudProviderOpenstackCloudProvider {
    blockStorage: outputs.GetClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorage;
    global: outputs.GetClusterRkeConfigCloudProviderOpenstackCloudProviderGlobal;
    loadBalancer: outputs.GetClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer;
    metadata: outputs.GetClusterRkeConfigCloudProviderOpenstackCloudProviderMetadata;
    route: outputs.GetClusterRkeConfigCloudProviderOpenstackCloudProviderRoute;
}

export interface GetClusterRkeConfigCloudProviderOpenstackCloudProviderBlockStorage {
    bsVersion: string;
    ignoreVolumeAz: boolean;
    trustDevicePath: boolean;
}

export interface GetClusterRkeConfigCloudProviderOpenstackCloudProviderGlobal {
    authUrl: string;
    caFile: string;
    domainId: string;
    domainName: string;
    password: string;
    region: string;
    tenantId: string;
    tenantName: string;
    trustId: string;
    username: string;
}

export interface GetClusterRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer {
    createMonitor: boolean;
    floatingNetworkId: string;
    lbMethod: string;
    lbProvider: string;
    lbVersion: string;
    manageSecurityGroups: boolean;
    monitorDelay?: string;
    monitorMaxRetries?: number;
    monitorTimeout?: string;
    subnetId: string;
    useOctavia: boolean;
}

export interface GetClusterRkeConfigCloudProviderOpenstackCloudProviderMetadata {
    requestTimeout: number;
    searchOrder: string;
}

export interface GetClusterRkeConfigCloudProviderOpenstackCloudProviderRoute {
    routerId: string;
}

export interface GetClusterRkeConfigCloudProviderVsphereCloudProvider {
    disk: outputs.GetClusterRkeConfigCloudProviderVsphereCloudProviderDisk;
    global: outputs.GetClusterRkeConfigCloudProviderVsphereCloudProviderGlobal;
    network: outputs.GetClusterRkeConfigCloudProviderVsphereCloudProviderNetwork;
    virtualCenters: outputs.GetClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenter[];
    workspace: outputs.GetClusterRkeConfigCloudProviderVsphereCloudProviderWorkspace;
}

export interface GetClusterRkeConfigCloudProviderVsphereCloudProviderDisk {
    scsiControllerType: string;
}

export interface GetClusterRkeConfigCloudProviderVsphereCloudProviderGlobal {
    datacenters: string;
    insecureFlag: boolean;
    password: string;
    port: string;
    soapRoundtripCount: number;
    user: string;
}

export interface GetClusterRkeConfigCloudProviderVsphereCloudProviderNetwork {
    publicNetwork: string;
}

export interface GetClusterRkeConfigCloudProviderVsphereCloudProviderVirtualCenter {
    datacenters: string;
    name: string;
    password: string;
    port: string;
    soapRoundtripCount: number;
    user: string;
}

export interface GetClusterRkeConfigCloudProviderVsphereCloudProviderWorkspace {
    datacenter: string;
    defaultDatastore: string;
    folder: string;
    resourcepoolPath: string;
    server: string;
}

export interface GetClusterRkeConfigDns {
    nodeSelector: {[key: string]: any};
    nodelocal?: outputs.GetClusterRkeConfigDnsNodelocal;
    provider?: string;
    reverseCidrs: string[];
    upstreamNameservers: string[];
}

export interface GetClusterRkeConfigDnsNodelocal {
    ipAddress?: string;
    nodeSelector?: {[key: string]: any};
}

export interface GetClusterRkeConfigIngress {
    dnsPolicy: string;
    extraArgs: {[key: string]: any};
    nodeSelector: {[key: string]: any};
    options: {[key: string]: any};
    provider: string;
}

export interface GetClusterRkeConfigMonitoring {
    nodeSelector?: {[key: string]: any};
    options: {[key: string]: any};
    provider: string;
    replicas: number;
    updateStrategy?: outputs.GetClusterRkeConfigMonitoringUpdateStrategy;
}

export interface GetClusterRkeConfigMonitoringUpdateStrategy {
    rollingUpdate?: outputs.GetClusterRkeConfigMonitoringUpdateStrategyRollingUpdate;
    strategy?: string;
}

export interface GetClusterRkeConfigMonitoringUpdateStrategyRollingUpdate {
    maxSurge?: number;
    maxUnavailable?: number;
}

export interface GetClusterRkeConfigNetwork {
    calicoNetworkProvider?: outputs.GetClusterRkeConfigNetworkCalicoNetworkProvider;
    canalNetworkProvider?: outputs.GetClusterRkeConfigNetworkCanalNetworkProvider;
    flannelNetworkProvider?: outputs.GetClusterRkeConfigNetworkFlannelNetworkProvider;
    mtu?: number;
    options: {[key: string]: any};
    plugin: string;
    weaveNetworkProvider?: outputs.GetClusterRkeConfigNetworkWeaveNetworkProvider;
}

export interface GetClusterRkeConfigNetworkCalicoNetworkProvider {
    cloudProvider: string;
}

export interface GetClusterRkeConfigNetworkCanalNetworkProvider {
    iface: string;
}

export interface GetClusterRkeConfigNetworkFlannelNetworkProvider {
    iface: string;
}

export interface GetClusterRkeConfigNetworkWeaveNetworkProvider {
    password: string;
}

export interface GetClusterRkeConfigNode {
    address: string;
    dockerSocket: string;
    hostnameOverride?: string;
    internalAddress?: string;
    labels?: {[key: string]: any};
    nodeId?: string;
    port?: string;
    roles: string[];
    sshAgentAuth?: boolean;
    sshKey: string;
    sshKeyPath: string;
    user: string;
}

export interface GetClusterRkeConfigPrivateRegistry {
    isDefault?: boolean;
    password?: string;
    url: string;
    user?: string;
}

export interface GetClusterRkeConfigServices {
    etcd: outputs.GetClusterRkeConfigServicesEtcd;
    kubeApi: outputs.GetClusterRkeConfigServicesKubeApi;
    kubeController: outputs.GetClusterRkeConfigServicesKubeController;
    kubelet: outputs.GetClusterRkeConfigServicesKubelet;
    kubeproxy: outputs.GetClusterRkeConfigServicesKubeproxy;
    scheduler: outputs.GetClusterRkeConfigServicesScheduler;
}

export interface GetClusterRkeConfigServicesEtcd {
    backupConfig: outputs.GetClusterRkeConfigServicesEtcdBackupConfig;
    caCert: string;
    cert: string;
    creation: string;
    externalUrls?: string[];
    extraArgs: {[key: string]: any};
    extraBinds?: string[];
    extraEnvs?: string[];
    gid?: number;
    image: string;
    key: string;
    path: string;
    retention: string;
    snapshot: boolean;
    uid?: number;
}

export interface GetClusterRkeConfigServicesEtcdBackupConfig {
    enabled?: boolean;
    intervalHours?: number;
    retention?: number;
    s3BackupConfig?: outputs.GetClusterRkeConfigServicesEtcdBackupConfigS3BackupConfig;
    safeTimestamp?: boolean;
}

export interface GetClusterRkeConfigServicesEtcdBackupConfigS3BackupConfig {
    accessKey?: string;
    bucketName: string;
    customCa?: string;
    endpoint: string;
    folder?: string;
    region?: string;
    secretKey?: string;
}

export interface GetClusterRkeConfigServicesKubeApi {
    admissionConfiguration?: {[key: string]: any};
    alwaysPullImages?: boolean;
    auditLog?: outputs.GetClusterRkeConfigServicesKubeApiAuditLog;
    eventRateLimit?: outputs.GetClusterRkeConfigServicesKubeApiEventRateLimit;
    extraArgs: {[key: string]: any};
    extraBinds?: string[];
    extraEnvs?: string[];
    image: string;
    podSecurityPolicy?: boolean;
    secretsEncryptionConfig?: outputs.GetClusterRkeConfigServicesKubeApiSecretsEncryptionConfig;
    serviceClusterIpRange: string;
    serviceNodePortRange: string;
}

export interface GetClusterRkeConfigServicesKubeApiAuditLog {
    configuration: outputs.GetClusterRkeConfigServicesKubeApiAuditLogConfiguration;
    enabled?: boolean;
}

export interface GetClusterRkeConfigServicesKubeApiAuditLogConfiguration {
    format?: string;
    maxAge?: number;
    maxBackup?: number;
    maxSize?: number;
    path?: string;
    policy: string;
}

export interface GetClusterRkeConfigServicesKubeApiEventRateLimit {
    configuration: string;
    enabled?: boolean;
}

export interface GetClusterRkeConfigServicesKubeApiSecretsEncryptionConfig {
    customConfig?: string;
    enabled?: boolean;
}

export interface GetClusterRkeConfigServicesKubeController {
    clusterCidr: string;
    extraArgs: {[key: string]: any};
    extraBinds?: string[];
    extraEnvs?: string[];
    image: string;
    serviceClusterIpRange: string;
}

export interface GetClusterRkeConfigServicesKubelet {
    clusterDnsServer: string;
    clusterDomain: string;
    extraArgs: {[key: string]: any};
    extraBinds?: string[];
    extraEnvs?: string[];
    failSwapOn: boolean;
    generateServingCertificate?: boolean;
    image: string;
    infraContainerImage: string;
}

export interface GetClusterRkeConfigServicesKubeproxy {
    extraArgs: {[key: string]: any};
    extraBinds?: string[];
    extraEnvs?: string[];
    image: string;
}

export interface GetClusterRkeConfigServicesScheduler {
    extraArgs: {[key: string]: any};
    extraBinds?: string[];
    extraEnvs?: string[];
    image: string;
}

export interface GetClusterRkeConfigUpgradeStrategy {
    drain?: boolean;
    drainInput: outputs.GetClusterRkeConfigUpgradeStrategyDrainInput;
    maxUnavailableControlplane?: string;
    maxUnavailableWorker?: string;
}

export interface GetClusterRkeConfigUpgradeStrategyDrainInput {
    deleteLocalData?: boolean;
    force?: boolean;
    gracePeriod?: number;
    ignoreDaemonSets?: boolean;
    timeout?: number;
}

export interface GetClusterScanScanConfig {
    cisScanConfig: outputs.GetClusterScanScanConfigCisScanConfig;
}

export interface GetClusterScanScanConfigCisScanConfig {
    debugMaster?: boolean;
    debugWorker?: boolean;
    overrideBenchmarkVersion?: string;
    overrideSkips?: string[];
    profile?: string;
}

export interface GetClusterScheduledClusterScan {
    enabled?: boolean;
    scanConfig: outputs.GetClusterScheduledClusterScanScanConfig;
    scheduleConfig: outputs.GetClusterScheduledClusterScanScheduleConfig;
}

export interface GetClusterScheduledClusterScanScanConfig {
    cisScanConfig: outputs.GetClusterScheduledClusterScanScanConfigCisScanConfig;
}

export interface GetClusterScheduledClusterScanScanConfigCisScanConfig {
    debugMaster?: boolean;
    debugWorker?: boolean;
    overrideBenchmarkVersion?: string;
    overrideSkips?: string[];
    profile?: string;
}

export interface GetClusterScheduledClusterScanScheduleConfig {
    cronSchedule: string;
    retention: number;
}

export interface GetClusterTemplateMember {
    accessType?: string;
    groupPrincipalId?: string;
    userPrincipalId?: string;
}

export interface GetClusterTemplateTemplateRevision {
    annotations: {[key: string]: any};
    clusterConfig: outputs.GetClusterTemplateTemplateRevisionClusterConfig;
    clusterTemplateId: string;
    default?: boolean;
    enabled?: boolean;
    id: string;
    labels: {[key: string]: any};
    name: string;
    questions?: outputs.GetClusterTemplateTemplateRevisionQuestion[];
}

export interface GetClusterTemplateTemplateRevisionClusterConfig {
    clusterAuthEndpoint: outputs.GetClusterTemplateTemplateRevisionClusterConfigClusterAuthEndpoint;
    defaultClusterRoleForProjectMembers: string;
    defaultPodSecurityPolicyTemplateId: string;
    desiredAgentImage: string;
    desiredAuthImage: string;
    dockerRootDir: string;
    enableClusterAlerting?: boolean;
    enableClusterMonitoring?: boolean;
    enableNetworkPolicy?: boolean;
    rkeConfig: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfig;
    scheduledClusterScan?: outputs.GetClusterTemplateTemplateRevisionClusterConfigScheduledClusterScan;
    windowsPreferedCluster?: boolean;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigClusterAuthEndpoint {
    caCerts?: string;
    enabled?: boolean;
    fqdn?: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfig {
    addonJobTimeout: number;
    addons?: string;
    addonsIncludes?: string[];
    authentication: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthentication;
    authorization: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthorization;
    bastionHost: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigBastionHost;
    cloudProvider: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProvider;
    dns: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDns;
    ignoreDockerVersion?: boolean;
    ingress: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigIngress;
    kubernetesVersion: string;
    monitoring: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoring;
    network: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetwork;
    nodes?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNode[];
    prefixPath: string;
    privateRegistries?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistry[];
    services: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServices;
    sshAgentAuth?: boolean;
    sshCertPath: string;
    sshKeyPath: string;
    upgradeStrategy: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategy;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthentication {
    sans: string[];
    strategy: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigAuthorization {
    mode?: string;
    options: {[key: string]: any};
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigBastionHost {
    address: string;
    port?: string;
    sshAgentAuth?: boolean;
    sshKey: string;
    sshKeyPath: string;
    user: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProvider {
    awsCloudProvider?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProvider;
    azureCloudProvider?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAzureCloudProvider;
    customCloudProvider: string;
    name: string;
    openstackCloudProvider?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProvider;
    vsphereCloudProvider?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProvider;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProvider {
    global: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderGlobal;
    serviceOverrides?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderServiceOverride[];
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderGlobal {
    disableSecurityGroupIngress?: boolean;
    disableStrictZoneCheck?: boolean;
    elbSecurityGroup: string;
    kubernetesClusterId: string;
    kubernetesClusterTag: string;
    roleArn: string;
    routeTableId: string;
    subnetId: string;
    vpc: string;
    zone: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAwsCloudProviderServiceOverride {
    region: string;
    service: string;
    signingMethod: string;
    signingName: string;
    signingRegion: string;
    url: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderAzureCloudProvider {
    aadClientCertPassword: string;
    aadClientCertPath: string;
    aadClientId: string;
    aadClientSecret: string;
    cloud: string;
    cloudProviderBackoff: boolean;
    cloudProviderBackoffDuration: number;
    cloudProviderBackoffExponent: number;
    cloudProviderBackoffJitter: number;
    cloudProviderBackoffRetries: number;
    cloudProviderRateLimit: boolean;
    cloudProviderRateLimitBucket: number;
    cloudProviderRateLimitQps: number;
    loadBalancerSku?: string;
    location: string;
    maximumLoadBalancerRuleCount: number;
    primaryAvailabilitySetName: string;
    primaryScaleSetName: string;
    resourceGroup: string;
    routeTableName: string;
    securityGroupName: string;
    subnetName: string;
    subscriptionId: string;
    tenantId: string;
    useInstanceMetadata: boolean;
    useManagedIdentityExtension: boolean;
    vmType: string;
    vnetName: string;
    vnetResourceGroup: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProvider {
    blockStorage: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderBlockStorage;
    global: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderGlobal;
    loadBalancer: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer;
    metadata: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderMetadata;
    route: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderRoute;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderBlockStorage {
    bsVersion: string;
    ignoreVolumeAz: boolean;
    trustDevicePath: boolean;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderGlobal {
    authUrl: string;
    caFile: string;
    domainId: string;
    domainName: string;
    password: string;
    region: string;
    tenantId: string;
    tenantName: string;
    trustId: string;
    username: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderLoadBalancer {
    createMonitor: boolean;
    floatingNetworkId: string;
    lbMethod: string;
    lbProvider: string;
    lbVersion: string;
    manageSecurityGroups: boolean;
    monitorDelay?: string;
    monitorMaxRetries?: number;
    monitorTimeout?: string;
    subnetId: string;
    useOctavia: boolean;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderMetadata {
    requestTimeout: number;
    searchOrder: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderOpenstackCloudProviderRoute {
    routerId: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProvider {
    disk: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderDisk;
    global: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderGlobal;
    network: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderNetwork;
    virtualCenters: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderVirtualCenter[];
    workspace: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderWorkspace;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderDisk {
    scsiControllerType: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderGlobal {
    datacenters: string;
    insecureFlag: boolean;
    password: string;
    port: string;
    soapRoundtripCount: number;
    user: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderNetwork {
    publicNetwork: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderVirtualCenter {
    datacenters: string;
    name: string;
    password: string;
    port: string;
    soapRoundtripCount: number;
    user: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigCloudProviderVsphereCloudProviderWorkspace {
    datacenter: string;
    defaultDatastore: string;
    folder: string;
    resourcepoolPath: string;
    server: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDns {
    nodeSelector: {[key: string]: any};
    nodelocal?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsNodelocal;
    provider?: string;
    reverseCidrs: string[];
    upstreamNameservers: string[];
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigDnsNodelocal {
    ipAddress?: string;
    nodeSelector?: {[key: string]: any};
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigIngress {
    dnsPolicy: string;
    extraArgs: {[key: string]: any};
    nodeSelector: {[key: string]: any};
    options: {[key: string]: any};
    provider: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoring {
    nodeSelector?: {[key: string]: any};
    options: {[key: string]: any};
    provider: string;
    replicas: number;
    updateStrategy?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategy;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategy {
    rollingUpdate?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyRollingUpdate;
    strategy?: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigMonitoringUpdateStrategyRollingUpdate {
    maxSurge?: number;
    maxUnavailable?: number;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetwork {
    calicoNetworkProvider?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCalicoNetworkProvider;
    canalNetworkProvider?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCanalNetworkProvider;
    flannelNetworkProvider?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkFlannelNetworkProvider;
    mtu?: number;
    options: {[key: string]: any};
    plugin: string;
    weaveNetworkProvider?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkWeaveNetworkProvider;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCalicoNetworkProvider {
    cloudProvider: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkCanalNetworkProvider {
    iface: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkFlannelNetworkProvider {
    iface: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNetworkWeaveNetworkProvider {
    password: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigNode {
    address: string;
    dockerSocket: string;
    hostnameOverride?: string;
    internalAddress?: string;
    labels?: {[key: string]: any};
    nodeId?: string;
    port?: string;
    roles: string[];
    sshAgentAuth?: boolean;
    sshKey: string;
    sshKeyPath: string;
    user: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigPrivateRegistry {
    isDefault?: boolean;
    password?: string;
    url: string;
    user?: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServices {
    etcd: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcd;
    kubeApi: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApi;
    kubeController: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeController;
    kubelet: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubelet;
    kubeproxy: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeproxy;
    scheduler: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesScheduler;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcd {
    backupConfig: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfig;
    caCert: string;
    cert: string;
    creation: string;
    externalUrls?: string[];
    extraArgs: {[key: string]: any};
    extraBinds?: string[];
    extraEnvs?: string[];
    gid?: number;
    image: string;
    key: string;
    path: string;
    retention: string;
    snapshot: boolean;
    uid?: number;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfig {
    enabled?: boolean;
    intervalHours?: number;
    retention?: number;
    s3BackupConfig?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfigS3BackupConfig;
    safeTimestamp?: boolean;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesEtcdBackupConfigS3BackupConfig {
    accessKey?: string;
    bucketName: string;
    customCa?: string;
    endpoint: string;
    folder?: string;
    region?: string;
    secretKey?: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApi {
    admissionConfiguration?: {[key: string]: any};
    alwaysPullImages?: boolean;
    auditLog?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLog;
    eventRateLimit?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiEventRateLimit;
    extraArgs: {[key: string]: any};
    extraBinds?: string[];
    extraEnvs?: string[];
    image: string;
    podSecurityPolicy?: boolean;
    secretsEncryptionConfig?: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiSecretsEncryptionConfig;
    serviceClusterIpRange: string;
    serviceNodePortRange: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLog {
    configuration: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLogConfiguration;
    enabled?: boolean;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiAuditLogConfiguration {
    format?: string;
    maxAge?: number;
    maxBackup?: number;
    maxSize?: number;
    path?: string;
    policy: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiEventRateLimit {
    configuration: string;
    enabled?: boolean;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeApiSecretsEncryptionConfig {
    customConfig?: string;
    enabled?: boolean;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeController {
    clusterCidr: string;
    extraArgs: {[key: string]: any};
    extraBinds?: string[];
    extraEnvs?: string[];
    image: string;
    serviceClusterIpRange: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubelet {
    clusterDnsServer: string;
    clusterDomain: string;
    extraArgs: {[key: string]: any};
    extraBinds?: string[];
    extraEnvs?: string[];
    failSwapOn: boolean;
    generateServingCertificate?: boolean;
    image: string;
    infraContainerImage: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesKubeproxy {
    extraArgs: {[key: string]: any};
    extraBinds?: string[];
    extraEnvs?: string[];
    image: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigServicesScheduler {
    extraArgs: {[key: string]: any};
    extraBinds?: string[];
    extraEnvs?: string[];
    image: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategy {
    drain?: boolean;
    drainInput: outputs.GetClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyDrainInput;
    maxUnavailableControlplane?: string;
    maxUnavailableWorker?: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigRkeConfigUpgradeStrategyDrainInput {
    deleteLocalData?: boolean;
    force?: boolean;
    gracePeriod?: number;
    ignoreDaemonSets?: boolean;
    timeout?: number;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigScheduledClusterScan {
    enabled?: boolean;
    scanConfig: outputs.GetClusterTemplateTemplateRevisionClusterConfigScheduledClusterScanScanConfig;
    scheduleConfig: outputs.GetClusterTemplateTemplateRevisionClusterConfigScheduledClusterScanScheduleConfig;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigScheduledClusterScanScanConfig {
    cisScanConfig: outputs.GetClusterTemplateTemplateRevisionClusterConfigScheduledClusterScanScanConfigCisScanConfig;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigScheduledClusterScanScanConfigCisScanConfig {
    debugMaster?: boolean;
    debugWorker?: boolean;
    overrideBenchmarkVersion?: string;
    overrideSkips?: string[];
    profile?: string;
}

export interface GetClusterTemplateTemplateRevisionClusterConfigScheduledClusterScanScheduleConfig {
    cronSchedule: string;
    retention: number;
}

export interface GetClusterTemplateTemplateRevisionQuestion {
    default: string;
    required?: boolean;
    type?: string;
    variable: string;
}

export interface GetEtcdBackupBackupConfig {
    enabled?: boolean;
    intervalHours?: number;
    retention?: number;
    s3BackupConfig?: outputs.GetEtcdBackupBackupConfigS3BackupConfig;
    safeTimestamp?: boolean;
}

export interface GetEtcdBackupBackupConfigS3BackupConfig {
    accessKey?: string;
    bucketName: string;
    customCa?: string;
    endpoint: string;
    folder?: string;
    region?: string;
    secretKey?: string;
}

export interface GetMultiClusterAppAnswer {
    clusterId: string;
    projectId: string;
    values: {[key: string]: any};
}

export interface GetMultiClusterAppMember {
    accessType?: string;
    groupPrincipalId?: string;
    userPrincipalId?: string;
}

export interface GetMultiClusterAppTarget {
    appId: string;
    healthState: string;
    projectId: string;
    state: string;
}

export interface GetMultiClusterAppUpgradeStrategy {
    rollingUpdate?: outputs.GetMultiClusterAppUpgradeStrategyRollingUpdate;
}

export interface GetMultiClusterAppUpgradeStrategyRollingUpdate {
    batchSize?: number;
    interval?: number;
}

export interface GetNamespaceContainerResourceLimit {
    limitsCpu?: string;
    limitsMemory?: string;
    requestsCpu?: string;
    requestsMemory?: string;
}

export interface GetNamespaceResourceQuota {
    limit: outputs.GetNamespaceResourceQuotaLimit;
}

export interface GetNamespaceResourceQuotaLimit {
    configMaps?: string;
    limitsCpu?: string;
    limitsMemory?: string;
    persistentVolumeClaims?: string;
    pods?: string;
    replicationControllers?: string;
    requestsCpu?: string;
    requestsMemory?: string;
    requestsStorage?: string;
    secrets?: string;
    services?: string;
    servicesLoadBalancers?: string;
    servicesNodePorts?: string;
}

export interface GetNodePoolNodeTaint {
    effect?: string;
    key: string;
    timeAdded: string;
    value: string;
}

export interface GetNotifierPagerdutyConfig {
    proxyUrl?: string;
    serviceKey: string;
}

export interface GetNotifierSlackConfig {
    defaultRecipient: string;
    proxyUrl?: string;
    url: string;
}

export interface GetNotifierSmtpConfig {
    defaultRecipient: string;
    host: string;
    password?: string;
    port: number;
    sender: string;
    tls?: boolean;
    username?: string;
}

export interface GetNotifierWebhookConfig {
    proxyUrl?: string;
    url: string;
}

export interface GetNotifierWechatConfig {
    agent: string;
    corp: string;
    defaultRecipient: string;
    proxyUrl?: string;
    recipientType?: string;
    secret: string;
}

export interface GetPodSecurityPolicyTemplateAllowedCsiDriver {
    name: string;
}

export interface GetPodSecurityPolicyTemplateAllowedFlexVolume {
    driver: string;
}

export interface GetPodSecurityPolicyTemplateAllowedHostPath {
    pathPrefix: string;
    readOnly?: boolean;
}

export interface GetPodSecurityPolicyTemplateFsGroup {
    ranges: outputs.GetPodSecurityPolicyTemplateFsGroupRange[];
    rule?: string;
}

export interface GetPodSecurityPolicyTemplateFsGroupRange {
    max: number;
    min: number;
}

export interface GetPodSecurityPolicyTemplateHostPort {
    max: number;
    min: number;
}

export interface GetPodSecurityPolicyTemplateRunAsGroup {
    ranges?: outputs.GetPodSecurityPolicyTemplateRunAsGroupRange[];
    rule: string;
}

export interface GetPodSecurityPolicyTemplateRunAsGroupRange {
    max: number;
    min: number;
}

export interface GetPodSecurityPolicyTemplateRunAsUser {
    ranges?: outputs.GetPodSecurityPolicyTemplateRunAsUserRange[];
    rule: string;
}

export interface GetPodSecurityPolicyTemplateRunAsUserRange {
    max: number;
    min: number;
}

export interface GetPodSecurityPolicyTemplateRuntimeClass {
    allowedRuntimeClassNames: string[];
    defaultRuntimeClassName?: string;
}

export interface GetPodSecurityPolicyTemplateSeLinux {
    rule: string;
    seLinuxOption?: outputs.GetPodSecurityPolicyTemplateSeLinuxSeLinuxOption;
}

export interface GetPodSecurityPolicyTemplateSeLinuxSeLinuxOption {
    level?: string;
    role?: string;
    type?: string;
    user?: string;
}

export interface GetPodSecurityPolicyTemplateSupplementalGroup {
    ranges: outputs.GetPodSecurityPolicyTemplateSupplementalGroupRange[];
    rule?: string;
}

export interface GetPodSecurityPolicyTemplateSupplementalGroupRange {
    max: number;
    min: number;
}

export interface GetProjectAlertGroupRecipient {
    defaultRecipient?: boolean;
    notifierId: string;
    notifierType: string;
    recipient: string;
}

export interface GetProjectAlertRuleMetricRule {
    comparison?: string;
    description?: string;
    duration: string;
    expression: string;
    thresholdValue: number;
}

export interface GetProjectAlertRulePodRule {
    condition?: string;
    podId: string;
    restartIntervalSeconds?: number;
    restartTimes?: number;
}

export interface GetProjectAlertRuleWorkloadRule {
    availablePercentage?: number;
    selector?: {[key: string]: any};
    workloadId?: string;
}

export interface GetProjectContainerResourceLimit {
    limitsCpu?: string;
    limitsMemory?: string;
    requestsCpu?: string;
    requestsMemory?: string;
}

export interface GetProjectLoggingCustomTargetConfig {
    certificate?: string;
    clientCert?: string;
    clientKey?: string;
    content: string;
}

export interface GetProjectLoggingElasticsearchConfig {
    authPassword?: string;
    authUsername?: string;
    certificate?: string;
    clientCert?: string;
    clientKey?: string;
    clientKeyPass?: string;
    dateFormat?: string;
    endpoint: string;
    indexPrefix?: string;
    sslVerify: boolean;
    sslVersion?: string;
}

export interface GetProjectLoggingFluentdConfig {
    certificate?: string;
    compress?: boolean;
    enableTls?: boolean;
    fluentServers: outputs.GetProjectLoggingFluentdConfigFluentServer[];
}

export interface GetProjectLoggingFluentdConfigFluentServer {
    endpoint: string;
    hostname?: string;
    password?: string;
    sharedKey?: string;
    standby?: boolean;
    username?: string;
    weight?: number;
}

export interface GetProjectLoggingKafkaConfig {
    brokerEndpoints?: string[];
    certificate?: string;
    clientCert?: string;
    clientKey?: string;
    topic: string;
    zookeeperEndpoint?: string;
}

export interface GetProjectLoggingSplunkConfig {
    certificate?: string;
    clientCert?: string;
    clientKey?: string;
    clientKeyPass?: string;
    endpoint: string;
    index?: string;
    source?: string;
    sslVerify: boolean;
    token: string;
}

export interface GetProjectLoggingSyslogConfig {
    certificate?: string;
    clientCert?: string;
    clientKey?: string;
    enableTls?: boolean;
    endpoint: string;
    program?: string;
    protocol?: string;
    severity?: string;
    sslVerify: boolean;
    token?: string;
}

export interface GetProjectResourceQuota {
    namespaceDefaultLimit: outputs.GetProjectResourceQuotaNamespaceDefaultLimit;
    projectLimit: outputs.GetProjectResourceQuotaProjectLimit;
}

export interface GetProjectResourceQuotaNamespaceDefaultLimit {
    configMaps?: string;
    limitsCpu?: string;
    limitsMemory?: string;
    persistentVolumeClaims?: string;
    pods?: string;
    replicationControllers?: string;
    requestsCpu?: string;
    requestsMemory?: string;
    requestsStorage?: string;
    secrets?: string;
    services?: string;
    servicesLoadBalancers?: string;
    servicesNodePorts?: string;
}

export interface GetProjectResourceQuotaProjectLimit {
    configMaps?: string;
    limitsCpu?: string;
    limitsMemory?: string;
    persistentVolumeClaims?: string;
    pods?: string;
    replicationControllers?: string;
    requestsCpu?: string;
    requestsMemory?: string;
    requestsStorage?: string;
    secrets?: string;
    services?: string;
    servicesLoadBalancers?: string;
    servicesNodePorts?: string;
}

export interface GetRegistryRegistry {
    address: string;
    password?: string;
    username?: string;
}

export interface GetRoleTempalteRule {
    apiGroups?: string[];
    nonResourceUrls?: string[];
    resourceNames?: string[];
    resources?: string[];
    verbs?: string[];
}

export interface GetRoleTemplateRule {
    apiGroups?: string[];
    nonResourceUrls?: string[];
    resourceNames?: string[];
    resources?: string[];
    verbs?: string[];
}

export interface MultiClusterAppAnswer {
    clusterId: string;
    projectId: string;
    values: {[key: string]: any};
}

export interface MultiClusterAppMember {
    accessType?: string;
    groupPrincipalId?: string;
    userPrincipalId?: string;
}

export interface MultiClusterAppTarget {
    appId: string;
    healthState: string;
    projectId: string;
    state: string;
}

export interface MultiClusterAppUpgradeStrategy {
    rollingUpdate?: outputs.MultiClusterAppUpgradeStrategyRollingUpdate;
}

export interface MultiClusterAppUpgradeStrategyRollingUpdate {
    batchSize?: number;
    interval?: number;
}

export interface NamespaceContainerResourceLimit {
    limitsCpu?: string;
    limitsMemory?: string;
    requestsCpu?: string;
    requestsMemory?: string;
}

export interface NamespaceResourceQuota {
    limit: outputs.NamespaceResourceQuotaLimit;
}

export interface NamespaceResourceQuotaLimit {
    configMaps?: string;
    limitsCpu?: string;
    limitsMemory?: string;
    persistentVolumeClaims?: string;
    pods?: string;
    replicationControllers?: string;
    requestsCpu?: string;
    requestsMemory?: string;
    requestsStorage?: string;
    secrets?: string;
    services?: string;
    servicesLoadBalancers?: string;
    servicesNodePorts?: string;
}

export interface NodePoolNodeTaint {
    effect?: string;
    key: string;
    timeAdded: string;
    value: string;
}

export interface NodeTemplateAmazonec2Config {
    accessKey?: string;
    ami: string;
    blockDurationMinutes?: string;
    deviceName?: string;
    encryptEbsVolume?: boolean;
    endpoint?: string;
    iamInstanceProfile?: string;
    insecureTransport?: boolean;
    instanceType?: string;
    keypairName?: string;
    kmsKey?: string;
    monitoring?: boolean;
    openPorts?: string[];
    privateAddressOnly?: boolean;
    region: string;
    requestSpotInstance?: boolean;
    retries?: string;
    rootSize?: string;
    secretKey?: string;
    securityGroupReadonly?: boolean;
    securityGroups: string[];
    sessionToken?: string;
    spotPrice?: string;
    sshKeypath?: string;
    sshUser?: string;
    subnetId: string;
    tags?: string;
    useEbsOptimizedInstance?: boolean;
    usePrivateAddress?: boolean;
    userdata?: string;
    volumeType?: string;
    vpcId: string;
    zone: string;
}

export interface NodeTemplateAzureConfig {
    availabilitySet?: string;
    clientId?: string;
    clientSecret?: string;
    customData?: string;
    diskSize?: string;
    dns?: string;
    dockerPort?: string;
    environment?: string;
    faultDomainCount?: string;
    image?: string;
    location?: string;
    managedDisks?: boolean;
    noPublicIp?: boolean;
    nsg?: string;
    openPorts?: string[];
    privateIpAddress?: string;
    resourceGroup?: string;
    size?: string;
    sshUser?: string;
    staticPublicIp?: boolean;
    storageType?: string;
    subnet?: string;
    subnetPrefix?: string;
    subscriptionId?: string;
    updateDomainCount?: string;
    usePrivateIp?: boolean;
    vnet?: string;
}

export interface NodeTemplateDigitaloceanConfig {
    accessToken?: string;
    backups?: boolean;
    image?: string;
    ipv6?: boolean;
    monitoring?: boolean;
    privateNetworking?: boolean;
    region?: string;
    size?: string;
    sshKeyFingerprint?: string;
    sshKeyPath?: string;
    sshPort?: string;
    sshUser?: string;
    tags?: string;
    userdata?: string;
}

export interface NodeTemplateLinodeConfig {
    authorizedUsers?: string;
    createPrivateIp?: boolean;
    dockerPort?: string;
    image?: string;
    instanceType?: string;
    label?: string;
    region?: string;
    rootPass?: string;
    sshPort?: string;
    sshUser?: string;
    stackscript?: string;
    stackscriptData?: string;
    swapSize?: string;
    tags?: string;
    token?: string;
    uaPrefix?: string;
}

export interface NodeTemplateOpennebulaConfig {
    b2dSize?: string;
    cpu?: string;
    devPrefix?: string;
    disableVnc?: boolean;
    diskResize?: string;
    imageId?: string;
    imageName?: string;
    imageOwner?: string;
    memory?: string;
    networkId?: string;
    networkName?: string;
    networkOwner?: string;
    password: string;
    sshUser?: string;
    templateId?: string;
    templateName?: string;
    user: string;
    vcpu?: string;
    xmlRpcUrl: string;
}

export interface NodeTemplateOpenstackConfig {
    activeTimeout?: string;
    authUrl: string;
    availabilityZone: string;
    cacert?: string;
    configDrive?: boolean;
    domainId?: string;
    domainName?: string;
    endpointType?: string;
    flavorId?: string;
    flavorName?: string;
    floatingIpPool?: string;
    imageId?: string;
    imageName?: string;
    insecure?: boolean;
    ipVersion?: string;
    keypairName?: string;
    netId?: string;
    netName?: string;
    novaNetwork?: boolean;
    password?: string;
    privateKeyFile?: string;
    region: string;
    secGroups?: string;
    sshPort?: string;
    sshUser?: string;
    tenantId?: string;
    tenantName?: string;
    userDataFile?: string;
    username: string;
}

export interface NodeTemplateVsphereConfig {
    boot2dockerUrl?: string;
    cfgparams?: string[];
    cloneFrom?: string;
    cloudConfig?: string;
    cloudinit?: string;
    contentLibrary?: string;
    cpuCount?: string;
    creationType?: string;
    customAttributes?: string[];
    datacenter?: string;
    datastore?: string;
    datastoreCluster?: string;
    diskSize?: string;
    folder?: string;
    hostsystem?: string;
    memorySize?: string;
    networks?: string[];
    password?: string;
    pool?: string;
    sshPassword?: string;
    sshPort?: string;
    sshUser?: string;
    sshUserGroup?: string;
    tags?: string[];
    username?: string;
    vappIpAllocationPolicy?: string;
    vappIpProtocol?: string;
    vappProperties?: string[];
    vappTransport?: string;
    vcenter?: string;
    vcenterPort?: string;
}

export interface NotifierPagerdutyConfig {
    proxyUrl?: string;
    serviceKey: string;
}

export interface NotifierSlackConfig {
    defaultRecipient: string;
    proxyUrl?: string;
    url: string;
}

export interface NotifierSmtpConfig {
    defaultRecipient: string;
    host: string;
    password?: string;
    port: number;
    sender: string;
    tls?: boolean;
    username?: string;
}

export interface NotifierWebhookConfig {
    proxyUrl?: string;
    url: string;
}

export interface NotifierWechatConfig {
    agent: string;
    corp: string;
    defaultRecipient: string;
    proxyUrl?: string;
    recipientType?: string;
    secret: string;
}

export interface PodSecurityPolicyTemplateAllowedCsiDriver {
    name: string;
}

export interface PodSecurityPolicyTemplateAllowedFlexVolume {
    driver: string;
}

export interface PodSecurityPolicyTemplateAllowedHostPath {
    pathPrefix: string;
    readOnly?: boolean;
}

export interface PodSecurityPolicyTemplateFsGroup {
    ranges: outputs.PodSecurityPolicyTemplateFsGroupRange[];
    rule?: string;
}

export interface PodSecurityPolicyTemplateFsGroupRange {
    max: number;
    min: number;
}

export interface PodSecurityPolicyTemplateHostPort {
    max: number;
    min: number;
}

export interface PodSecurityPolicyTemplateRunAsGroup {
    ranges?: outputs.PodSecurityPolicyTemplateRunAsGroupRange[];
    rule: string;
}

export interface PodSecurityPolicyTemplateRunAsGroupRange {
    max: number;
    min: number;
}

export interface PodSecurityPolicyTemplateRunAsUser {
    ranges?: outputs.PodSecurityPolicyTemplateRunAsUserRange[];
    rule: string;
}

export interface PodSecurityPolicyTemplateRunAsUserRange {
    max: number;
    min: number;
}

export interface PodSecurityPolicyTemplateRuntimeClass {
    allowedRuntimeClassNames: string[];
    defaultRuntimeClassName?: string;
}

export interface PodSecurityPolicyTemplateSeLinux {
    rule: string;
    seLinuxOption?: outputs.PodSecurityPolicyTemplateSeLinuxSeLinuxOption;
}

export interface PodSecurityPolicyTemplateSeLinuxSeLinuxOption {
    level?: string;
    role?: string;
    type?: string;
    user?: string;
}

export interface PodSecurityPolicyTemplateSupplementalGroup {
    ranges: outputs.PodSecurityPolicyTemplateSupplementalGroupRange[];
    rule?: string;
}

export interface PodSecurityPolicyTemplateSupplementalGroupRange {
    max: number;
    min: number;
}

export interface ProjectAlertGroupRecipient {
    defaultRecipient?: boolean;
    notifierId: string;
    notifierType: string;
    recipient: string;
}

export interface ProjectAlertRuleMetricRule {
    comparison?: string;
    description?: string;
    duration: string;
    expression: string;
    thresholdValue: number;
}

export interface ProjectAlertRulePodRule {
    condition?: string;
    podId: string;
    restartIntervalSeconds?: number;
    restartTimes?: number;
}

export interface ProjectAlertRuleWorkloadRule {
    availablePercentage?: number;
    selector?: {[key: string]: any};
    workloadId?: string;
}

export interface ProjectContainerResourceLimit {
    limitsCpu?: string;
    limitsMemory?: string;
    requestsCpu?: string;
    requestsMemory?: string;
}

export interface ProjectLoggingCustomTargetConfig {
    certificate?: string;
    clientCert?: string;
    clientKey?: string;
    content: string;
}

export interface ProjectLoggingElasticsearchConfig {
    authPassword?: string;
    authUsername?: string;
    certificate?: string;
    clientCert?: string;
    clientKey?: string;
    clientKeyPass?: string;
    dateFormat?: string;
    endpoint: string;
    indexPrefix?: string;
    sslVerify: boolean;
    sslVersion?: string;
}

export interface ProjectLoggingFluentdConfig {
    certificate?: string;
    compress?: boolean;
    enableTls?: boolean;
    fluentServers: outputs.ProjectLoggingFluentdConfigFluentServer[];
}

export interface ProjectLoggingFluentdConfigFluentServer {
    endpoint: string;
    hostname?: string;
    password?: string;
    sharedKey?: string;
    standby?: boolean;
    username?: string;
    weight?: number;
}

export interface ProjectLoggingKafkaConfig {
    brokerEndpoints?: string[];
    certificate?: string;
    clientCert?: string;
    clientKey?: string;
    topic: string;
    zookeeperEndpoint?: string;
}

export interface ProjectLoggingSplunkConfig {
    certificate?: string;
    clientCert?: string;
    clientKey?: string;
    clientKeyPass?: string;
    endpoint: string;
    index?: string;
    source?: string;
    sslVerify: boolean;
    token: string;
}

export interface ProjectLoggingSyslogConfig {
    certificate?: string;
    clientCert?: string;
    clientKey?: string;
    enableTls?: boolean;
    endpoint: string;
    program?: string;
    protocol?: string;
    severity?: string;
    sslVerify: boolean;
    token?: string;
}

export interface ProjectProjectMonitoringInput {
    answers?: {[key: string]: any};
    version?: string;
}

export interface ProjectResourceQuota {
    namespaceDefaultLimit: outputs.ProjectResourceQuotaNamespaceDefaultLimit;
    projectLimit: outputs.ProjectResourceQuotaProjectLimit;
}

export interface ProjectResourceQuotaNamespaceDefaultLimit {
    configMaps?: string;
    limitsCpu?: string;
    limitsMemory?: string;
    persistentVolumeClaims?: string;
    pods?: string;
    replicationControllers?: string;
    requestsCpu?: string;
    requestsMemory?: string;
    requestsStorage?: string;
    secrets?: string;
    services?: string;
    servicesLoadBalancers?: string;
    servicesNodePorts?: string;
}

export interface ProjectResourceQuotaProjectLimit {
    configMaps?: string;
    limitsCpu?: string;
    limitsMemory?: string;
    persistentVolumeClaims?: string;
    pods?: string;
    replicationControllers?: string;
    requestsCpu?: string;
    requestsMemory?: string;
    requestsStorage?: string;
    secrets?: string;
    services?: string;
    servicesLoadBalancers?: string;
    servicesNodePorts?: string;
}

export interface RegistryRegistry {
    address: string;
    password?: string;
    username?: string;
}

export interface RoleTempalteRule {
    apiGroups?: string[];
    nonResourceUrls?: string[];
    resourceNames?: string[];
    resources?: string[];
    verbs?: string[];
}
